<<<<<<< Updated upstream
import{C as o}from"./bundler.js";const r=(r,e,...l)=>{if(o.o){const o=Object.entries({...a.l,...a[r]??{}}).map((([o,r])=>`${o}: ${r};`)).join(" ");switch(r){case"group":console.groupCollapsed(`%c${e}`,o);break;case"groupEnd":console.groupEnd();break;default:console.groupCollapsed(`%c${e}`,o,...l),console.trace(),console.groupEnd()}}},a={l:{background:"#000000",color:"#EDB620","font-family":"Pragmata Pro",padding:"0 25px"},display:{color:"#EDB620","font-family":"AlverataInformalW01-Regular","font-size":"16px","margin-left":"-100px",padding:"0 100px"},error:{color:"#FF0000",background:"#950A0F","font-weight":"bold"},group:{background:"#EDB620",color:"black","font-weight":"bold","text-transform":"uppercase"},groupEnd:{}},e={group:o=>r("group",o),groupEnd:()=>r("groupEnd",""),display:(o,...a)=>r("display",o,...a),log:(o,...a)=>r("base",o,...a),error:(o,...a)=>r("error",o,...a)};export default e;
=======
import{C as e,U as o,XItem as t,XGroup as r,XPool as a,XDie as n,XTermType as i,XOrbitType as s,XRoll as l}from"./bundler.js";const c=(o,t,...r)=>{if(e.o){const e=Object.entries({...d.t,...d[o]??{}}).map((([e,o])=>`${e}: ${o};`)).join(" ");r.length?"NOGROUP"===r[0]?console.log(`%c${t}`,e):(console.groupCollapsed(`%c${t}`,e,...r),console.trace(),console.groupEnd()):console.groupCollapsed(`%c${t}`,e)}},d={t:{background:"#000000",color:"#EDB620","font-family":"Pragmata Pro",padding:"0 25px"},display:{background:"#EDB620",color:"black","font-family":"AlverataInformalW01-Regular","font-size":"16px",padding:"0 10vw 0 10px"},error:{color:"#FF0000",background:"#950A0F","font-weight":"bold"},info:{background:"transparent",color:"white","font-weight":"bold","font-family":"Pragmata Pro"},groupEnd:{}},y={display:(e,...o)=>c("display",e,...o.length?o:["NOGROUP"]),log:(e,...o)=>c("base",e,...o.length?o:["NOGROUP"]),info:(e,...o)=>c("info",e,...o.length?o:["NOGROUP"]),error:(e,...o)=>c("error",e,...o.length?o:["NOGROUP"]),i:e=>c("display",e),l:e=>c("base",e),u:e=>c("info",e),g:e=>c("error",e),groupEnd:()=>console.groupEnd()},u={p:()=>{const e=new a(t.R,{id:"translate-box",m:["translate-box"],P:{set:{h:0,k:0},to:{x:"+=500",duration:5,O:"power3.inOut",repeat:-1,$:!0}}}),o=new r(e,{id:"scale-box-1",m:["scale-box"],P:{set:{h:0,k:0},to:{scale:2,duration:15,O:"sine.inOut",repeat:-1,$:!0}}}),s=new r(o,{id:"scale-box-2",m:["extra-scale-box"],P:{set:{h:0,k:0},to:{scale:3,duration:5,O:"sine.inOut",repeat:-1,$:!0}}}),l=new r(s,{id:"rotate-box-1",m:["rotate-box"],P:{set:{h:0,k:0},to:{rotation:"+=360",duration:2,O:"none",repeat:-1}}}),c=new r(l,{id:"rotate-box-2",m:["rotate-box"],P:{set:{h:0,k:0},to:{rotation:"-=360",duration:2,O:"power4.inOut",repeat:-1}}}),d=new n(c,{id:"test-die",type:i.v,value:3,color:"lime",size:50}),u=[{x:.5,y:0,background:"yellow"},{x:0,y:1,background:"cyan"},{x:1,y:1,background:"magenta"}].map((({x:e,y:o,background:r},a)=>new t(d,{id:`die-marker-${a+1}`,m:["x-marker"],P:{set:{height:10,width:10,x:50*e,y:50*o,background:r}}}))),b=["yellow","cyan","magenta"].map(((e,o)=>new t(t.R,{id:`x-marker-${o+1}`,m:["x-marker"],P:{set:{height:10,width:10,x:100+20*o,y:500+40*o,background:e}}})));b.forEach(((e,o)=>{e.D((()=>{u[o].G&&e.set(u[o].N)}))})),[d,...u,...b].forEach((e=>e.initialize())),y.log("Test Die Objs =>",u,b,e,o,l,d)},C:(o=t.R,{id:r,x:n,y:i,size:l=200,color:c="cyan",T:d=e.U})=>new a(o,{id:r,P:{set:{height:l,width:l,left:n-.5*l,top:i-.5*l,j:c}},T:{[s.A]:{F:-.8,rotationRate:.5},[s.I]:{F:1.5,rotationRate:1},[s.B]:{F:.15,rotationRate:1}}}),L:({value:e,color:o="white",W:r="black",q:a="black",size:s=50}={})=>new n(t.R,{id:"x-die",type:i.v,value:e,color:o,W:r,q:a,size:s}),H:async()=>{const r=[{x:950,y:650,size:400,color:"rgba(255, 0, 0, 0.5)",T:{[s.B]:{F:.35,rotationRate:1},[s.A]:{F:1,rotationRate:1},[s.I]:{F:1.5,rotationRate:1}},J:{K:[6,"cyan",[2,"lime"]],M:[5,"silver",[3,"gold"],[4,"rgba(0, 0, 255, 0.5)"]],inner:[3,"red"]}}].map((async({x:r,y:a,size:l,color:c,T:d,J:b},g)=>{const x=u.C(t.R,{id:`test-pool-${g+1}`,x:r,y:a,size:l,color:c,T:d});await x.initialize(),globalThis.CIRCLE??(globalThis.CIRCLE=[]),globalThis.CIRCLE.push(x);for(const[r,[a,l,...c]]of Object.entries(b)){for(let e=0;e<a;e++){const a=`${x.id}-x-die-${e+1}`;await x.S(new n(t.R,{id:a,type:i.v,value:o.V(0,9),color:"string"==typeof l?l:void 0}),r)||y.error(`Error rendering xDie '${a}'`)}if(c.length){y.log("Nested Pools",c);for(const[a,l]of c){const c=u.C(t.R,{id:`test-pool-${g+1}-nested-pool-${o.X()}`,x:0,y:0,size:75,color:l,T:e.U});await x.S(c,r),await c.initialize();for(let e=0;e<a;e++){const r=`${c.id}-x-die-${e+1}`;try{await c.S(new n(t.R,{id:r,type:i.v,value:o.V(0,9),color:"string"==typeof l?l:void 0}),s.A)}catch(e){y.error(`Error rendering xDie '${r}'`)}}}}}}));return await Promise.allSettled(r),globalThis.POOLS=r,Promise.allSettled(r)},Y:async e=>{const o=new l(t.R,{id:"test-roll",Z:!0,P:{set:{x:500,y:500,height:400,width:400}}});await o.initialize();const r=["white","cyan","gold","lime"];let a=0;const c=e.flatMap((e=>{const o=r.shift();return[...new Array(e)].map((()=>new n(t.R,{id:"xDie"+a++,type:i.v,value:0,color:o})))}));return await Promise.allSettled(c.map((e=>e.initialize()))),o._({[s.A]:c}),o}};export{y as default,u as TESTS};
>>>>>>> Stashed changes
