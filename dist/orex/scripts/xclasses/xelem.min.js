// â–®â–®â–®â–®â–®â–®â–® IMPORTS â–®â–®â–®â–®â–®â–®â–®
import { 
// ====== GreenSock Animation ======
gsap, MotionPathPlugin, 
// â–®â–®â–®â–®â–®â–®â–®[Utility]â–®â–®â–®â–®â–®â–®â–®
U, 
// â–®â–®â–®â–®â–®â–®â–® XItems â–®â–®â–®â–®â–®â–®â–®
XItem, XROOT
 } from "../helpers/bundler.js";
// ðŸŸ©ðŸŸ©ðŸŸ© XElem: Contains & Controls a DOM Element Linked to an XItem ðŸŸ©ðŸŸ©ðŸŸ©
export default class XElem {
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ CONSTRUCTOR & Essential Fields â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    id;
    renderApp;
    get elem() { return this.renderApp.element[0]; }
    get elem$() { return $(this.elem); }
    constructor(renderApp) {
        this.renderApp = renderApp;
        this.id = this.renderApp.id;
    }
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ Parenting: Adopting & Managing Child XItems â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    get parentApp() { return this.renderApp.xParent; }
    adopt(child, isRetainingPosition = true) {
        child.xParent?.unregisterXKid(child);
        this.renderApp.registerXKid(child);
        // If both the renderApp and child are already initialized, assume retaining position.
        if (this.renderApp.isInitialized && child.isInitialized) {
            child.set({
                ...this.getLocalPosData(child),
                ...child.xOptions.isFreezingRotate ? { rotation: -1 * this.global.rotation } : {}
            });
        }
        child.elem$.appendTo(this.elem);
    }
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ Positioning: Positioning DOM Element in Local and Global (XROOT) Space â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–‘â–‘â–‘â–‘â–‘â–‘â–‘ Local Space â–‘â–‘â–‘â–‘â–‘â–‘â–‘
    get x() { return U.pInt(U.get(this.elem, "x", "px")); }
    get y() { return U.pInt(U.get(this.elem, "y", "px")); }
    get pos() { return { x: this.x, y: this.y }; }
    get rotation() { return U.pFloat(U.get(this.elem, "rotation"), 2); }
    get scale() { return U.pFloat(U.get(this.elem, "scale"), 2) || 1; }
    get origin() {
        return {
            x: -1 * (gsap.getProperty(this.elem, "xPercent") / 100) * this.width,
            y: -1 * (gsap.getProperty(this.elem, "yPercent") / 100) * this.height
        };
    }
    // â–‘â–‘â–‘â–‘â–‘â–‘â–‘ Global (XROOT) Space â–‘â–‘â–‘â–‘â–‘â–‘â–‘
    get global() {
        const self = this;
        return {
            get pos() {
                return MotionPathPlugin.convertCoordinates(self.elem, XROOT.XROOT.elem, self.origin);
            },
            get x() { return this.pos.x; },
            get y() { return this.pos.y; },
            get rotation() {
                let totalRotation = self.rotation, { parentApp } = self;
                while (parentApp?.isRendered) {
                    totalRotation += parentApp.rotation;
                    parentApp = parentApp.xParent;
                }
                return totalRotation;
            },
            get scale() {
                let totalScale = self.scale, { parentApp } = self;
                while (parentApp?.isRendered) {
                    totalScale *= parentApp.scale;
                    parentApp = parentApp.xParent;
                }
                return totalScale;
            },
            get height() { return this.height; },
            get width() { return this.width; }
        };
    }
    get height() { return U.pInt(U.get(this.elem, "height", "px")); }
    get width() { return U.pInt(U.get(this.elem, "width", "px")); }
    get size() { return (this.height + this.width) / 2; }
    // â–‘â–‘â–‘â–‘â–‘â–‘â–‘ Converting from Global Space to Element's Local Space â–‘â–‘â–‘â–‘â–‘â–‘â–‘
    getLocalPosData(ofItem, globalPoint) {
        return {
            ...MotionPathPlugin.convertCoordinates(XROOT.XROOT.elem, this.elem, globalPoint ?? ofItem.global.pos),
            rotation: ofItem.global.rotation - this.global.rotation,
            scale: ofItem.global.scale / this.global.scale,
            height: ofItem.height,
            width: ofItem.width
        };
    }
    // â–‘â–‘â–‘â–‘â–‘â–‘â–‘ Relative Positions â–‘â–‘â–‘â–‘â–‘â–‘â–‘
    getDistanceTo(posRef, globalPoint) {
        const { x: tGlobalX, y: tGlobalY } = posRef instanceof XItem ? posRef.global : posRef;
        return U.getDistance({ x: tGlobalX, y: tGlobalY }, globalPoint ?? this.global);
    }
    getGlobalAngleTo(posRef, globalPoint) {
        const { x: tGlobalX, y: tGlobalY } = posRef instanceof XItem ? posRef.global : posRef;
        return U.getAngle({ x: tGlobalX, y: tGlobalY }, globalPoint ?? this.global);
    }

    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ GSAP: GSAP Animation Method Wrappers â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    tweens = {};
    /*~ Figure out a way to have to / from / fromTo methods on all XItems that:
            - will adjust animation timescale based on a maximum time to maximum distance ratio(and minspeed ratio ?)
            - if timescale is small enough, just uses.set() ~*/
    scaleTween(tween, { scalingDuration, ...vars }, fromVal) {
        const duration = tween.duration();
        const { scaleTarget, maxDelta, minDur = 0 } = scalingDuration ?? {};
        if (typeof scaleTarget === "string" && typeof maxDelta === "number") {
            const startVal = U.get(this.elem, scaleTarget);
            const endVal = fromVal ?? vars[scaleTarget];
            if (typeof startVal === "number" && typeof duration === "number") {
                const delta = endVal - startVal;
                let scaleFactor = delta / maxDelta;
                if (minDur > 0 && (duration * scaleFactor) < minDur) {
                    scaleFactor = duration / minDur;
                }
                tween.timeScale(scaleFactor);
            }
        }
        return tween;
    }
    set(vars) {
        if (!this.renderApp.isInitialized) {
            this.renderApp.onRenderOptions = {
                ...this.renderApp.onRenderOptions,
                ...vars
            };
            return true;
        }
        return gsap.set(this.elem, vars);
    }
    to({ scalingDuration, ...vars }) {
        const tween = gsap.to(this.elem, vars);
        if (vars.id) {
            this.tweens[vars.id] = tween;
        }
        if (scalingDuration) {
            this.scaleTween(tween, { scalingDuration, ...vars });
        }
        return tween;
    }
    from({ scalingDuration, ...vars }) {
        const tween = gsap.from(this.elem, vars);
        if (vars.id) {
            this.tweens[vars.id] = tween;
        }
        if (scalingDuration && scalingDuration.scaleTarget) {
            const fromVal = vars[scalingDuration.scaleTarget];
            if (typeof U.get(this.elem, scalingDuration.scaleTarget) === "number") {
                this.scaleTween(tween, {
                    scalingDuration,
                    ...vars,
                    [scalingDuration.scaleTarget]: U.get(this.elem, scalingDuration.scaleTarget)
                }, fromVal);
            }
        }
        return tween;
    }
    fromTo(fromVars, { scalingDuration, ...toVars }) {
        const tween = gsap.fromTo(this.elem, fromVars, toVars);
        if (toVars.id) {
            this.tweens[toVars.id] = tween;
        }
        if (scalingDuration && scalingDuration.scaleTarget) {
            const fromVal = fromVars[scalingDuration.scaleTarget] ?? U.get(this.elem, scalingDuration.scaleTarget);
            this.scaleTween(tween, { scalingDuration, ...toVars }, typeof fromVal === "number" ? fromVal : U.pInt(U.get(this.elem, scalingDuration.scaleTarget)));
        }
        return tween;
    }
}