<<<<<<< Updated upstream
import{C as t,U as s,DB as e,XItem as r,XDie as i}from"../helpers/bundler.js";export default class n extends r{static get t(){return s.i(super.t,{o:["x-group"]})}get h(){return super.h}set h(t){super.h=t}constructor(t,s){super(t,s)}}class o extends r{constructor(t,s){super(s,{id:`${s.id}-arm-${s.u.size}`,p:!0}),this.l=t,this.g(t,!1),t instanceof n&&this.l.set({})}static get t(){return s.i(super.t,{o:["x-arm"],m:{set:{height:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%",P:0,O:0}}})}async initialize(){return await super.initialize()?(this.l.set({right:-1*this.l.width}),this.g(this.l,!1),this.l.X()):Promise.resolve(!1)}}export class XOrbit extends n{constructor(t,s,e){super(e,{id:t,m:{set:{height:e.height,width:e.width,left:.5*e.width,top:.5*e.height}}});const r=this;this.to({rotation:"+=360",repeat:-1,duration:10*s,I:"none",R(){r.A.forEach((t=>{t.h?.$&&t.set({rotation:-1*t.h.global.rotation})}))}});this.j=s}static get t(){return s.i(super.t,{o:["x-orbit"]})}get D(){return Array.from(this.u)}get A(){return this.D.map((t=>t.l))}get M(){return.5*this.weight*this.h.width}get weight(){return this.j}set weight(t){this.j=t,this.U&&this.k()}k(){e.log(`[${this.id}] Updating Arms`,this.D);const t=360/this.D.length;this.D.forEach(((s,e)=>{s.to({width:this.M,rotation:t*e,delay:.2*e,I:"power2.inOut",duration:1})}))}async q(t,s=0){e.log(`[${this.id}] Adding XItem: ${t.id}`);const r=new o(t,this);return await r.initialize()?(this.k(),Promise.resolve(!0)):Promise.resolve(!1)}async v(t){const s=t.map(((t,s)=>{const e=new o(t,this);return this.g(e),e.initialize()}));return await Promise.allSettled(s)?(this.k(),Promise.resolve(!0)):Promise.resolve(!1)}}export class XPool extends n{constructor(s,{B:e,...r}){super(s,r),this.C=[],this.F=new Map,e=e??{...t.G},this.H=new Map(Object.entries(e)),this.H.forEach(((t,s)=>{this.F.set(s,new XOrbit(s,t,this))}))}static get t(){return s.i(super.t,{o:["x-pool"]})}get B(){return this.F}get J(){return Array.from(Object.values(this.B))}get A(){return this.J.map((t=>t.K(r))).flat()}async q(t,s){const e=this.B.get(s);return e instanceof XOrbit&&await e.initialize()?e.q(t):Promise.resolve(!1)}}export class XRoll extends XPool{constructor(){super(...arguments),this.L=!1}get N(){return this.L}get S(){return this.N?this.K(i,!0).map((t=>t.value||0)):[]}T(){this.K(i,!0).map((t=>t.V())),this.L=!0}}
=======
import{C as t,U as s,XItem as e,XDie as r,XAnimVars as i}from"../helpers/bundler.js";export default class n extends e{static get t(){return s.i(super.t,{o:["x-group"]})}get h(){return super.h}set h(t){super.h=t}get u(){return Array.from(this.p)}constructor(t,s){super(t,s)}}class o extends e{constructor(t,s){super(s,{id:`${s.id}-arm-${s.p.size}`,l:!0}),this.g=t,this.m(t,!1)}static get t(){return s.i(super.t,{o:["x-arm"],O:{set:{height:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%",P:0,X:0}}})}async initialize(){return await super.initialize()?(this.g.set({left:"unset",top:"unset",right:-1*this.g.width}),this.m(this.g,!1),this.g.R()):Promise.resolve(!1)}}export var XOrbitType;!function(t){t.I="Main",t.M="Core",t.A="Outer"}(XOrbitType||(XOrbitType={}));export class XOrbit extends n{constructor(t,s,e,r=1){super(e,{id:t,O:{set:{height:e.height,width:e.width,left:.5*e.width,top:.5*e.height},$:[t=>t.j()]}}),this.rotationAngle=s>0?"+=360":"-=360",this.D=r,this.T=Math.abs(s)}static get t(){return s.i(super.t,{o:["x-orbit"]})}get k(){return Array.from(this.p)}get u(){return this.k.map((t=>t.g))}get v(){return.5*this.weight*this.h.width}get weight(){return this.T}set weight(t){this.T=t,this.C&&this.G()}get q(){return 10*this.T*this.D}j(){const[{type:t,...s}]=i.B({F:this,rotation:this.rotationAngle,duration:this.q});this.to(s)}G(t=.5){const s=360/this.k.length,e=t/this.k.length;this.k.forEach(((r,i)=>{r.set({width:0,rotation:s*i-90}).to({width:this.v,delay:e*i,H:"back.out(8)",duration:t}).to({rotation:s*i,H:"power2.out",duration:t})}))}async J(t){const s=new o(t,this);return await s.initialize()?(this.G(),Promise.resolve(!0)):Promise.resolve(!1)}async K(t){const s=t.map((t=>{const s=new o(t,this);return this.m(s),s.initialize()}));return await Promise.allSettled(s)?(this.G(),Promise.resolve(!0)):Promise.resolve(!1)}}export class XPool extends n{constructor(e,{L:r=s.N(t.S),...i}){super(e,i),this.U=[],this.V=new Map,this.W=new Map,this.Y=new Map;for(const[t,{Z:s,rotationRate:e}]of Object.entries(r))this.W.set(t,s),this.Y.set(t,e),this.V.set(t,new XOrbit(t,s,this,e))}static get t(){return s.i(super.t,{o:["x-pool"],O:{set:{height:200,width:200}}})}get L(){return this.V}get _(){return Array.from(this.L.values())}get u(){return this._.map((t=>t.u)).flat()}async J(t,s){const e=this.L.get(s);return e instanceof XOrbit&&await e.initialize()?e.J(t):Promise.resolve(!1)}async K(t){const s=this;return Promise.allSettled(Object.entries(t).map((([t,e])=>e.map((e=>s.J(e,t))))))}}export class XRoll extends XPool{constructor(t,s){super(t,s),this.tt=!1}get st(){return this.tt}get et(){return this.st?this.rt(r,!0).map((t=>t.value||0)):[]}it(t=!1){if(t||!this.tt){this.tt=!0;const t=this.rt(r,!0);gsap.timeline().fadeDieText(`#${this.id} .x-die`).call((()=>t.map((t=>t.nt())))).pulseRolledDie(`#${this.id} .x-die`)}}}
>>>>>>> Stashed changes
