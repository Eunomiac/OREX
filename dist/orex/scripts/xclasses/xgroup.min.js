import{C as t,U as e,DB as s,XItem as r,XDie as i}from"../helpers/bundler.js";export default class n extends r{static get t(){return e.i(super.t,{o:["x-group"]})}get h(){return super.h}set h(t){super.h=t}constructor(t,e){super(t,e)}}class o extends r{constructor(t,e){super(e,{id:`${e.id}-arm-${e.u.size}`,l:!0}),this.p=t,this.g(t,!1)}static get t(){return e.i(super.t,{o:["x-arm"],m:{set:{height:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%",O:0,P:0}}})}async initialize(){return await super.initialize()?(this.p.set({left:"unset",top:"unset",right:-1*this.p.width}),this.g(this.p,!1),this.p.X()):Promise.resolve(!1)}}export class XOrbit extends n{constructor(t,e,s,r){super(s,{id:t,m:{set:{height:s.height,width:s.width,left:.5*s.width,top:.5*s.height},to:{rotation:(r>0?"+":"-")+"=360",duration:r,I:"none",repeat:-1}}}),this.$=r,this.A=e}static get t(){return e.i(super.t,{o:["x-orbit"]})}get R(){return Array.from(this.u)}get j(){return this.R.map((t=>t.p))}get D(){return.5*this.weight*this.h.width}get weight(){return this.A}set weight(t){this.A=t,this.M&&this.k()}get rotationRate(){return this.$}k(){s.log(`[${this.id}] Updating Arms`,this.R);const t=360/this.R.length;this.R.forEach(((e,s)=>{e.to({width:this.D,rotation:t*s,delay:.2*s,I:"power2.inOut",duration:1})}))}async F(t){s.log(`[${this.id}] Adding XItem: ${t.id}`);const e=new o(t,this);return await e.initialize()?(this.k(),t instanceof i&&r.L(t),Promise.resolve(!0)):Promise.resolve(!1)}async U(t){const e=t.map((t=>{const e=new o(t,this);return this.g(e),e.initialize()}));return await Promise.allSettled(e)?(this.k(),r.L(t.filter((t=>t instanceof i))),Promise.resolve(!0)):Promise.resolve(!1)}}export class XPool extends n{constructor(s,{q:r,...i}){super(s,i),this.v=[],this.B=new Map,this.C=new Map,this.G=new Map,r=r??e.H(t.J);for(const[t,{size:e,rotationRate:s}]of Object.entries(r))this.C.set(t,e),this.G.set(t,s),this.B.set(t,new XOrbit(t,e,this,s))}static get t(){return e.i(super.t,{o:["x-pool"]})}get q(){return this.B}get K(){return Array.from(Object.values(this.q))}get j(){return this.K.map((t=>t.j)).flat()}async F(t,e){s.group(`${t.constructor.name}.addXItem(${t.id}, ${e})`);const r=this.q.get(e);if(s.log("orbital",r),s.log("is XOrbit?",r instanceof XOrbit),r instanceof XOrbit&&await r.initialize()){s.log("Orbital Initialized, Adding Item...");const e=await r.F(t);return s.log("Item Added",e),s.groupEnd(),e}return s.error(`FAILED adding ${t.id} to '${e}' of ${t.id}`),Promise.resolve(!1)}}export class XRoll extends XPool{constructor(){super(...arguments),this.N=!1}get S(){return this.N}get T(){return this.S?this.V(i,!0).map((t=>t.value||0)):[]}W(){this.V(i,!0).map((t=>t.Y())),this.N=!0}}