import{C as t,U as s,DB as e,XItem as i,XDie as r,XMod as a,Dir as n}from"../helpers/bundler.js";export default class o extends i{static t=new Map;static get i(){return s.o(super.i,{h:["x-group"]})}get u(){return super.u}set u(t){super.u=t}get l(){return Array.from(this.p)}constructor(t,s){super(t,s)}}export class XArm extends i{static t=new Map;static get i(){return s.o(super.i,{h:["x-arm"],g:{set:{height:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%",m:0,R:0}}})}P;constructor(t,s){super(s,{id:"arm"}),this.P=t}async X(){return await this.P.initialize()?(await this.I(),this.O(this.P,!1),this.P.set({x:0,y:0}),Promise.resolve(!0)):Promise.reject(!1)}async initialize(){return await super.initialize()&&await this.P.initialize()?(this.set({T:`${this.P.width}px`}),this.u?.O(this,!1),this.X()):Promise.reject()}async I(){if(this.u&&await this.P.initialize()){const{x:t,y:e}=MotionPathPlugin.getRelativePosition(this.u.A,this.P.A,[.5,.5],[.5,.5]),i=s.M({x:0,y:0},{x:t,y:e}),r=s.S({x:0,y:0},{x:t,y:e}),a=this.global.rotation,n=s.$(a,r);return this.set({width:i,rotation:this.rotation+n})}return Promise.reject()}get G(){return this.P.size}}export var XOrbitType;!function(t){t.Y="Main",t.W="Inner",t.j="Outer"}(XOrbitType||(XOrbitType={}));export class XOrbit extends o{static t=new Map;static get i(){return s.o(super.i,{h:["x-orbit"]})}#t;#s;#e;get k(){return $(`#${this.id} > .x-arm`)}get N(){return Array.from(this.p)}get l(){return this.N.map((t=>t.P))}get U(){return this.l.filter((t=>t instanceof r||t instanceof a))}#i;get V(){return this.#i}set V(t){this.#i=t,this.v&&this.D()}get H(){return.5*this.V*this.u.width}get q(){return this.N.map((t=>t.G)).reduce(((t,s)=>t+s),0)}get B(){const t=360/this.q,s=[];let e=0;return this.N.forEach((i=>{e+=i.G,s.push((e-.5*i.G)*t)})),s}constructor(s,e,i,r){i??=t.C[s].V,r??=t.C[s].F,super(e,{id:s,g:{set:{height:e.height,width:e.width,left:.5*e.width,top:.5*e.height},J:[t=>t.K()]}}),this.#i=i,this.#t=Math.abs(r),this.#s=r>0?"+=360":"-=360",this.#e=10*this.#i*this.#t}K(t=n.L,s=10){this.v&&this.to({id:"rotationTween",rotation:(t===n.L?"+":"-")+"=360",duration:s,repeat:-1,Z:"none",_:this,tt(){this.U.forEach((t=>{t.st&&t.et&&t.u?.et&&t.set({rotation:-1*t.u.global.rotation})}))}})}it;rt(){this.v&&this.ht.ot.nt?.pause()}ut(){this.v&&this.ht.ot.nt?.play()}D(t=3,s){this.it&&clearTimeout(this.it),this.it=setTimeout((()=>{e.log("Update Arms RUNNING!");const i=this;gsap.timeline().to(this.k,{width:s??this.H,Z:"back.out(4)",duration:t,ct:{lt:1,from:"end"}},"<").to(this.k,{rotation:t=>i.B[t],Z:"power2.out",duration:t},"<")}),10)}async dt(t){const s=new XArm(t,this);return await s.initialize()?(this.D(),Promise.resolve(!0)):Promise.resolve(!1)}async gt(t){const s=t.map((t=>{const s=new XArm(t,this);return this.O(s),console.log(this.N),s.initialize()}));return await Promise.allSettled(s)?(this.D(),Promise.resolve(!0)):Promise.resolve(!1)}}export class XPool extends o{static t=new Map;static get i(){return s.o(super.i,{h:["x-pool"],g:{set:{height:200,width:200}}})}#r=[];#a=new Map;#n=new Map;#o=new Map;get xt(){return this.#a}get wt(){return Array.from(this.xt.values())}get l(){return this.wt.map((t=>t.l)).flat()}constructor(e,{xt:i=s.Rt(t.C),...r}){super(e,r);for(const[t,{V:s,F:e}]of Object.entries(i))this.#n.set(t,s),this.#o.set(t,e),this.#a.set(t,new XOrbit(t,this,s,e))}async dt(t,s){const e=this.xt.get(s);return e instanceof XOrbit&&await e.initialize()?e.dt(t):Promise.resolve(!1)}async gt(t){const s=this;return Promise.allSettled(Object.entries(t).map((async([t,e])=>await Promise.allSettled(e.map((async e=>await s.dt(e,t)))))))}rt(){this.wt.forEach((t=>t.rt()))}ut(){this.wt.forEach((t=>t.ut()))}}export class XRoll extends XPool{static t=new Map;#h=!1;get yt(){return this.#h}get bt(){return this.yt?this.Pt(r,!0).map((t=>t.value)):[]}get ft(){return $(`#${this.id} .x-die`)}get Xt(){return $(`#${this.id} .x-die .die-val`)}constructor(t,s){super(t,s)}It(t=!1,s=!0){if(t||!this.#h){this.#h=!0;const t=this.Pt(r,!0);s?gsap.timeline({ct:.1}).to(this.Xt,{color:"transparent",Ot:0,duration:.15,Z:"power2.out"}).call((()=>t.forEach((t=>t.Tt())))).to(this.Xt,{color:"black",Ot:1}):t.forEach((t=>t.Tt()))}}At(t){return this.xt.get(t)?.U.map((t=>t.value??0))??[]}get Mt(){return this.At(XOrbitType.Y)}get St(){const t=this.Mt.sort(),s=t.filter((s=>t.filter((t=>t===s)).length>1)),e=[];for(;s.length;){const t=s.pop(),i=e.findIndex((([s])=>s===t));i>=0?e[i].push(t):e.push([t])}return e}}export class XSource extends XPool{constructor(t,s){super(t,s)}}