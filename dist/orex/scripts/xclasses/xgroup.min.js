import{C as t,U as s,DB as e,XItem as i,XDie as r,XMod as a,Dir as n}from"../helpers/bundler.js";export default class o extends i{static t=new Map;static get i(){return s.o(super.i,{h:["x-group"]})}get u(){return super.u}set u(t){super.u=t}get l(){return Array.from(this.p)}constructor(t,s){super(t,s)}}class h extends i{static t=new Map;static get i(){return s.o(super.i,{h:["x-arm"],g:{set:{height:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%",m:0,R:0}}})}I;constructor(t,s){super(s,{id:"arm"}),this.I=t,this.O(this.I,!1)}async initialize(){return await super.initialize()?(this.set({P:`${this.I.width}px`}),this.O(this.I,!1),this.I.X()):Promise.reject()}async T(){return this.u&&await this.I.initialize()?this.set({width:s.A(this.I.global.M,this.u.global.M),rotation:s.S(this.u.global.rotation,s.$(this.I.global.M,this.u.global.M))}):Promise.reject()}get G(){return this.I.size}}export var XOrbitType;!function(t){t.Y="Main",t.j="Inner",t.k="Outer"}(XOrbitType||(XOrbitType={}));export class XOrbit extends o{static t=new Map;static get i(){return s.o(super.i,{h:["x-orbit"]})}#t;#s;#e;get N(){return $(`#${this.id} > .x-arm`)}get U(){return Array.from(this.p)}get l(){return this.U.map((t=>t.I))}get V(){return this.l.filter((t=>t instanceof r||t instanceof a))}#i;get W(){return this.#i}set W(t){this.#i=t,this.v&&this.D()}get q(){return.5*this.W*this.u.width}get B(){return this.U.map((t=>t.G)).reduce(((t,s)=>t+s),0)}get C(){const t=360/this.B,s=[];let e=0;return this.U.forEach((i=>{e+=i.G,s.push((e-.5*i.G)*t)})),s}constructor(s,e,i,r){i??=t.F[s].W,r??=t.F[s].H,super(e,{id:s,g:{set:{height:e.height,width:e.width,left:.5*e.width,top:.5*e.height},J:[t=>t.K()]}}),this.#i=i,this.#t=Math.abs(r),this.#s=r>0?"+=360":"-=360",this.#e=10*this.#i*this.#t}K(t=n.L,s=10){this.v&&this.to({id:"rotationTween",rotation:(t===n.L?"+":"-")+"=360",duration:s,repeat:-1,Z:"none",_:this,tt(){this.V.forEach((t=>{t.st&&t.u?.st&&t.set({rotation:-1*t.u.global.rotation})}))}})}et;it(){this.v&&this.ot.nt.rt?.pause()}ht(){this.v&&this.ot.nt.rt?.play()}D(t=3,s){this.et&&clearTimeout(this.et),this.et=setTimeout((()=>{e.log("Update Arms RUNNING!");const i=this;gsap.timeline().to(this.N,{width:s??this.q,Z:"back.out(4)",duration:t,ut:{ct:1,from:"end"}},"<").to(this.N,{rotation:t=>i.C[t],Z:"power2.out",duration:t},"<")}),10)}async lt(t){const s=new h(t,this);return await s.initialize()?(this.D(),Promise.resolve(!0)):Promise.resolve(!1)}async dt(t){const s=t.map((t=>{const s=new h(t,this);return this.O(s),console.log(this.U),s.initialize()}));return await Promise.allSettled(s)?(this.D(),Promise.resolve(!0)):Promise.resolve(!1)}}export class XPool extends o{static t=new Map;static get i(){return s.o(super.i,{h:["x-pool"],g:{set:{height:200,width:200}}})}#r=[];#a=new Map;#n=new Map;#o=new Map;get gt(){return this.#a}get xt(){return Array.from(this.gt.values())}get l(){return this.xt.map((t=>t.l)).flat()}constructor(e,{gt:i=s.Rt(t.F),...r}){super(e,r);for(const[t,{W:s,H:e}]of Object.entries(i))this.#n.set(t,s),this.#o.set(t,e),this.#a.set(t,new XOrbit(t,this,s,e))}async lt(t,s){const e=this.gt.get(s);return e instanceof XOrbit&&await e.initialize()?e.lt(t):Promise.resolve(!1)}async dt(t){const s=this;return Promise.allSettled(Object.entries(t).map((async([t,e])=>await Promise.allSettled(e.map((async e=>await s.lt(e,t)))))))}it(){this.xt.forEach((t=>t.it()))}ht(){this.xt.forEach((t=>t.ht()))}}export class XRoll extends XPool{static t=new Map;#h=!1;get wt(){return this.#h}get bt(){return this.wt?this.ft(r,!0).map((t=>t.value)):[]}get yt(){return $(`#${this.id} .x-die`)}get It(){return $(`#${this.id} .x-die .die-val`)}constructor(t,s){super(t,s)}Ot(t=!1,s=!0){if(t||!this.#h){this.#h=!0;const t=this.ft(r,!0);s?gsap.timeline({ut:.1}).to(this.It,{color:"transparent",Pt:0,duration:.15,Z:"power2.out"}).call((()=>t.forEach((t=>t.Xt())))).to(this.It,{color:"black",Pt:1}):t.forEach((t=>t.Xt()))}}Tt(t){return this.gt.get(t)?.V.map((t=>t.value??0))??[]}get At(){return this.Tt(XOrbitType.Y)}get Mt(){const t=this.At.sort(),s=t.filter((s=>t.filter((t=>t===s)).length>1)),e=[];for(;s.length;){const t=s.pop(),i=e.findIndex((([s])=>s===t));i>=0?e[i].push(t):e.push([t])}return e}}export class XSource extends XPool{constructor(t,s){super(t,s)}}