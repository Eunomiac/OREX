import{C as t,U as s,XItem as e}from"../helpers/bundler.js";class r extends e{constructor(t,s){super({id:`${s.id}-arm-${s.t.size}`,parent:s,i:{set:{height:2,rotation:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%"}}}),this.h=t,this.h.parent=this}static get o(){return s.u(super.o,{p:s.unique([...super.o.p,"x-arm"])})}async initialize(){return await super.initialize()?(this.h.set({right:-1*this.h.width}),this.h.parent=this,this.h.m()):Promise.resolve(!1)}}export default class i extends e{static get o(){return s.u(super.o,{p:s.unique([...super.o.p,"x-group"])})}get parent(){return super.parent}}export class XPool extends i{constructor({l:s,...e}){super(e),this.g=[],this.O=new Map,s=s??{...t.P},this.X=new Map(Object.entries(s)),this.X.forEach(((t,s)=>{this.O.set(s,new XOrbit(s,t,this))}))}get l(){return this.O}get I(){return Array.from(Object.values(this.l))}get j(){return this.I.map((t=>t.R())).flat()}async A(t,s){return this.O.has(s)?this.l.get(s)?.A(t)??Promise.resolve(!1):Promise.resolve(!1)}}export class XOrbit extends i{constructor(t,s,e){super({id:t,parent:e,i:{set:{width:s*e.width}}}),this.M=[],this.$=s}get k(){return this.M}get j(){return this.k.map((t=>t.h))}get q(){return.5*this.weight*this.parent.width}get weight(){return this.$}set weight(t){this.$=t,this.v&&this.B()}B(){const t=360/this.k.length;this.k.forEach(((s,e)=>{s.to({width:this.q,rotation:t*e,delay:.2*e,C:"power2.inOut",duration:1})}))}async A(t,s=0){const e=new r(t,this);return await e.initialize()?(this.B(),Promise.resolve(!0)):Promise.resolve(!1)}async D(t){const s=t.map(((t,s)=>new r(t,this).initialize()));return await Promise.allSettled(s)?(this.B(),Promise.resolve(!0)):Promise.resolve(!1)}}