var t,e,s,r,i,a,n,o,h,u=this&&this.t||function(t,e,s,r,i){if("m"===r)throw new TypeError("Private method is not writable");if("a"===r&&!i)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?t!==e||!i:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===r?i.call(t,s):i?i.value=s:e.set(t,s),s},c=this&&this.i||function(t,e,s,r){if("a"===s&&!r)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!r:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===s?r:"a"===s?r.call(t):r?r.value:e.get(t)};import{C as p,U as d,DB as l,XItem as w,XDie as f,XMod as m,Dir as g}from"../helpers/bundler.js";export default class x extends w{constructor(t,e){super(t,e)}static get o(){return d.h(super.o,{u:["x-group"]})}get p(){return super.p}set p(t){super.p=t}get l(){return Array.from(this.m)}}x.g=new Map;class b extends w{constructor(t,e){super(e,{id:"arm"}),this.M=t,this.P(t,!1)}static get o(){return d.h(super.o,{u:["x-arm"],X:{set:{height:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%",O:0,R:0}}})}async initialize(){return await super.initialize()?(this.M.set({left:"unset",top:"unset",right:-1*this.M.width}),this.P(this.M,!1),this.M.k()):Promise.resolve(!1)}}b.g=new Map;export var XOrbitType;!function(t){t.v="Main",t.T="Inner",t.I="Outer"}(XOrbitType||(XOrbitType={}));export class XOrbit extends x{constructor(i,a,n,o){n??=p.$[i].W,o??=p.$[i].A,super(a,{id:i,X:{set:{height:a.height,width:a.width,left:.5*a.width,top:.5*a.height},j:[t=>t.N()]}}),t.set(this,void 0),e.set(this,void 0),s.set(this,void 0),r.set(this,void 0),u(this,r,n,"f"),u(this,t,Math.abs(o),"f"),u(this,e,o>0?"+=360":"-=360","f"),u(this,s,10*c(this,r,"f")*c(this,t,"f"),"f")}static get o(){return d.h(super.o,{u:["x-orbit"]})}get S(){return $(`#${this.id} .x-arm`)}get U(){return Array.from(this.m)}get l(){return this.U.map((t=>t.M))}get C(){return this.l.filter((t=>t instanceof f||t instanceof m))}get W(){return c(this,r,"f")}set W(t){u(this,r,t,"f"),this.D&&this.G()}get V(){return.5*this.W*this.p.width}N(t=g.q,e=10){this.D&&this.to({id:"rotationTween",rotation:(t===g.q?"+":"-")+"=360",duration:e,repeat:-1,B:"none",F:this,H(){this.l.forEach((t=>{t.p?.J&&t.set({rotation:-1*t.p.global.rotation})}))}})}G(t=3,e){this.K&&clearTimeout(this.K),this.K=setTimeout((()=>{l.log("Update Arms RUNNING!");const s=360/this.U.length;gsap.timeline().to(this.S,{width:e??this.V,B:"back.out(4)",duration:t,L:{Y:1,from:"end"}},"<").to(this.S,{rotation:t=>s*t,B:"power2.out",duration:t},"<")}),10)}async Z(t){const e=new b(t,this);return await e.initialize()?(this.G(),Promise.resolve(!0)):Promise.resolve(!1)}async _(t){const e=t.map((t=>{const e=new b(t,this);return this.P(e),console.log(this.U),e.initialize()}));return await Promise.allSettled(e)?(this.G(),Promise.resolve(!0)):Promise.resolve(!1)}}t=new WeakMap,e=new WeakMap,s=new WeakMap,r=new WeakMap,XOrbit.g=new Map;export class XPool extends x{constructor(t,{tt:e=d.et(p.$),...s}){super(t,s),i.set(this,[]),a.set(this,new Map),n.set(this,new Map),o.set(this,new Map);for(const[t,{W:s,A:r}]of Object.entries(e))c(this,n,"f").set(t,s),c(this,o,"f").set(t,r),c(this,a,"f").set(t,new XOrbit(t,this,s,r))}static get o(){return d.h(super.o,{u:["x-pool"],X:{set:{height:200,width:200}}})}get tt(){return c(this,a,"f")}get st(){return Array.from(this.tt.values())}get l(){return this.st.map((t=>t.l)).flat()}async Z(t,e){const s=this.tt.get(e);return s instanceof XOrbit&&await s.initialize()?s.Z(t):Promise.resolve(!1)}async _(t){const e=this;return Promise.allSettled(Object.entries(t).map((([t,s])=>s.map((s=>e.Z(s,t))))))}}i=new WeakMap,a=new WeakMap,n=new WeakMap,o=new WeakMap,XPool.g=new Map;export class XRoll extends XPool{constructor(t,e){super(t,e),h.set(this,!1)}get rt(){return c(this,h,"f")}get it(){return this.rt?this.nt(f,!0).map((t=>t.value||0)):[]}get ot(){return $(`#${this.id} .x-die`)}get ht(){return $(`#${this.id} .x-die .die-val`)}ut(t=!1){if(t||!c(this,h,"f")){u(this,h,!0,"f");const t=this.nt(f,!0);gsap.timeline({L:.1}).to(this.ht,{color:"transparent",ct:0,duration:.15,B:"power2.out"}).call((()=>t.forEach((t=>t.dt())))).to(this.ht,{color:"black",ct:1})}}}h=new WeakMap,XRoll.g=new Map;export class XSource extends XPool{constructor(t,e){super(t,e)}}