import{C as t,U as s,DB as e,XItem as i,XDie as r}from"../helpers/bundler.js";export var XOrbitType;!function(t){t.t="Main",t.i="Core",t.o="Outer"}(XOrbitType||(XOrbitType={}));export default class n extends i{static get h(){return s.u(super.h,{p:["x-group"]})}get l(){return super.l}set l(t){super.l=t}constructor(t,s){super(t,s)}}class o extends i{constructor(t,s){super(s,{id:`${s.id}-arm-${s.g.size}`,m:!0}),this.O=t,this.P(t,!1)}static get h(){return s.u(super.h,{p:["x-arm"],X:{set:{height:0,width:0,transformOrigin:"0% 50%",top:"50%",left:"50%",R:0,I:0}}})}async initialize(){return await super.initialize()?(this.O.set({left:"unset",top:"unset",right:-1*this.O.width}),this.P(this.O,!1),this.O.$()):Promise.resolve(!1)}}export class XOrbit extends n{constructor(t,s,e,i=1){super(e,{id:t,X:{set:{height:e.height,width:e.width,left:.5*e.width,top:.5*e.height},A:[t=>t.M()]}}),this.rotationAngle=s>0?"+=360":"-=360",console.log(this.rotationAngle),this.j=i,this.D=Math.abs(s)}static get h(){return s.u(super.h,{p:["x-orbit"]})}get T(){return Array.from(this.g)}get k(){return this.T.map((t=>t.O))}get U(){return.5*this.weight*this.l.width}get weight(){return this.D}set weight(t){this.D=t,this.v&&this.C()}get S(){return 10*this.D*this.j}async M(){if(this.v){const t=this.to({rotation:this.rotationAngle,repeat:-1,duration:this.S,q:"none",B:this,F(){this.k.forEach((t=>{t.l?.G&&t.set({rotation:-1*t.l.global.rotation})}))}});t&&(this.H=t)}}C(){e.log(`[${this.id}] Updating Arms`,this.T);const t=360/this.T.length;this.T.forEach(((s,e)=>{s.to({width:this.U,rotation:t*e,delay:.2*e,q:"power2.inOut",duration:1})}))}async J(t){e.log(`[${this.id}] Adding XItem: ${t.id}`);const s=new o(t,this);return await s.initialize()?(this.C(),Promise.resolve(!0)):Promise.resolve(!1)}async K(t){const s=t.map((t=>{const s=new o(t,this);return this.P(s),s.initialize()}));return await Promise.allSettled(s)?(this.C(),Promise.resolve(!0)):Promise.resolve(!1)}}export class XPool extends n{constructor(e,{L:i=s.N(t.V),...r}){super(e,r),this.W=[],this.Y=new Map,this.Z=new Map,this._=new Map;for(const[t,{tt:s,rotationRate:e}]of Object.entries(i))this.Z.set(t,s),this._.set(t,e),this.Y.set(t,new XOrbit(t,s,this,e))}static get h(){return s.u(super.h,{p:["x-pool"],X:{set:{height:200,width:200}}})}get L(){return this.Y}get st(){return Array.from(Object.values(this.L))}get k(){return this.st.map((t=>t.k)).flat()}async J(t,s){const e=this.L.get(s);return e instanceof XOrbit&&await e.initialize()?e.J(t):Promise.resolve(!1)}async K(t){const s=this;return Promise.allSettled(Object.entries(t).map((([t,e])=>e.map((e=>s.J(e,t))))))}}export class XRoll extends XPool{constructor(t,s){super(t,s),this.et=!1}get it(){return this.et}get rt(){return this.it?this.nt(r,!0).map((t=>t.value||0)):[]}ot(t=!1){if(t||!this.et){this.et=!0;const t=this.nt(r,!0);gsap.timeline().fadeDieText(`#${this.id} .x-die`).call((()=>t.map((t=>t.ht())))).pulseRolledDie(`#${this.id} .x-die`)}}}