import{gsap as t,Dragger as e,InertiaPlugin as s,MotionPathPlugin as r,U as i,XElem as n,XItem as o,XDie as h,XSnap as c,MIX as a,HasSnapPath as l}from"../helpers/bundler.mjs";export default class u extends(a(n).t(l)){static get i(){return{...super.i,o:"pink",h:"yellow",l:"cyan",u:"purple"}}static get p(){return{...super.p,g:[...super.p.g,"x-circle"],S:"xCircle"}}static m({x:e,y:s}){const r=t.P._({values:Array.from(this.A.keys())},{x:e,y:s}),i=this.A.get(r);return{...r,$:i}}static k(t){if(t._)return t._;const{x:e,y:s,$:r}=this.m(t.I);return t.v?.name!==r.name&&(t.v?t.v.T(t).then((()=>r.F(t))):r.F(t)),{x:e,y:s,$:r}}static q(t){return this.m(t).$}constructor(t,e,s,r={}){super($(`\n    <div style="height: ${2*s}px; width: ${2*s}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${s}" cy="${s}" r="${s}" stroke="none"></circle>\n        <circle class="motion-path" cx="${s}" cy="${s}" r="${.8*s}" fill="none" stroke="none"></circle>\n      </svg>\n    </div>`),{properties:{x:t,y:e},C:{x:.8*s,y:.8*s},M:[`x-circle-${r.type??u.p.O}`],...r}),this.D(!0)}get U(){return this.j=this.j??[]}get B(){const e=new Map;let s=0;this.U.forEach((t=>{s+=t.L,e.set(t,s-.5*t.L)}));for(const[r,i]of e.entries())e.set(r,t.P.normalize(0,s,i));return e}get R(){return Array.from(this.B.values())}get W(){return Array.from(this.B.keys())}get G(){return this.N=this.N??new Map}X(e){e?[e].flat().forEach((e=>{t.Y(this.H,e),"rotation"===e&&delete this.J})):(t.Y(this.H),delete this.J)}D(e){Boolean(e)!==Boolean(this.J)&&(e?this.J=t.to(this.H,{rotation:"+=360",duration:100,repeat:-1,K:"none",V:this,Z(){this.U.forEach((t=>t.tt()))}}):(this.J.et(),delete this.J))}st(t,e){return t.length===e.length&&t.every(((t,s)=>t.name===e[s].name))}rt(e,s){if(e.length!==s.length)return!1;const r=s.findIndex((t=>t.name===e[0].name));if(i.it(r)&&e.every(((e,i)=>e.name===t.P.wrap(s,i+r).name))){const t=r-e.length;return Math.abs(t)>=r?r:t}return!1}nt(t,e){function s(t,e){const s=e.findIndex((e=>t===e));return e[s===e.length-1?0:s+1]}if(t=[...t],e=[...e],t.length!==e.length)return{isEqual:!1,ot:!1};if(t.every(((t,s)=>t===e[s])))return{isEqual:!0,ot:!0};const r={isEqual:!1,ot:!0};for(const i of t)if(s(i,t)!==s(i,e)){r.ot=!1;break}return r.ot&&(t[0]===e[1]?r.ht=0:t[1]===e[0]&&(r.ht=t.length-1)),r}ct(t){const{R:e}=this,s=e.findIndex(((e,s,r)=>s===r.length-1||e>=t));e.reverse();return[this.B.size-1-e.findIndex(((e,s,r)=>s===r.length-1||e<=t)),s]}lt({x:e,y:s}){if([e,s].includes(void 0))return!1;const r=this.ut({x:e,y:s});return t.P.normalize(-180,180,r)}yt({x:e,y:s}){if([e,s].includes(void 0))return!1;this.ut({x:e,y:s});const r=this.lt({x:e,y:s});if(!1!==r){const[e,s]=this.ct(r);return 0===s||e===s||t.P._([this.R[e],this.R[s]],r)===this.R[s]?s:e}return!1}dt(t){return{...this.gt(this.B.get(t)),slot:this.U.findIndex((e=>e===t))}}St(t){return[...t??this.U].map((e=>this.dt(e,t).ft))}xt(t){return this.U.find((e=>e._t?.name===t.name))}Pt(t){return this.dt(this.xt(t))}wt(t,e=this.U){return e.filter((e=>e!==t))}At(t,e,s=this.U){return e=e??s.length,[...s.slice(0,e),...[t].flat(),...s.slice(e)]}$t(t){const{slot:e}=this.dt(t);if(~e){const s=[...this.U];return s[e]=new c(t,{parent:this}),s}return!1}kt(t){const{slot:e}=this.Pt(t);if(~e){const s=[...this.U];return s[e]=t,s}return!1}async It(t,e=1){const s=[...this.U];if(this.st(s,t))return Promise.resolve();!1===this.rt(s,t)||s[0]!==t[1]&&s[1]!==t[0]||(t=[s[s.length-1],...s.slice(1,-1),s[0]]),this.j=[...t];const r=this.St(this.U);return Promise.allSettled(this.U.map(((t,e)=>t.Et(r[e]))))}async vt(t=1,e){const s=[...Array(t)].map((()=>new h({parent:this,type:e})));return this.It(this.At(s))}async Tt(t){this.It(this.wt(t)),t.et()}async Ft(t){return this.It(this.$t(t)).then((()=>this.qt(t)))}}