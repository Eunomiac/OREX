import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,U as r,XElem as n,XItem as o,XDie as h,XSnap as c,MIX as a,HasSnapPath as u}from"../helpers/bundler.mjs";export default class l extends(a(n).t(u)){static get i(){return{...super.i,o:"pink",h:"yellow",u:"cyan",l:"purple"}}static get p(){return{...super.p,m:[...super.p.m,"x-circle"],S:"xCircle"}}static g({x:s,y:e}){const i=t._.P({values:Array.from(this.I.keys())},{x:s,y:e}),r=this.I.get(i);return{...i,$:r}}static k(t){if(t.P)return t.P;const{x:s,y:e,$:i}=this.g(t.A);return t.v?.name!==i.name&&(t.v?t.v.F(t).then((()=>i.T(t))):i.T(t)),{x:s,y:e,$:i}}static C(t){return this.g(t).$}constructor(t,s,e,i={}){super($(`\n    <div style="height: ${2*e}px; width: ${2*e}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${e}" cy="${e}" r="${e}" stroke="none"></circle>\n        <circle class="motion-path" cx="${e}" cy="${e}" r="${.8*e}" fill="none" stroke="none"></circle>\n      </svg>\n    </div>`),{properties:{x:t,y:s},M:{x:.8*e,y:.8*e},U:[`x-circle-${i.type??l.p.W}`],...i}),this.q(!0)}get D(){return this.O=this.O??[]}get j(){const s=new Map;let e=0;this.D.forEach((t=>{e+=t.B,s.set(t,e-.5*t.B)}));for(const[i,r]of s.entries())s.set(i,t._.normalize(0,e,r));return s}get L(){return Array.from(this.j.values())}get N(){return Array.from(this.j.keys())}get R(){return this.X=this.X??new Map}Y(s){s?[s].flat().forEach((s=>{t.G(this.H,s),"rotation"===s&&delete this.J})):(t.G(this.H),delete this.J)}q(s){Boolean(s)!==Boolean(this.J)&&(s?this.J=t.to(this.H,{rotation:"+=360",duration:100,repeat:-1,K:"none",V:this,Z(){this.D.forEach((t=>t.tt()))}}):(this.J.st(),delete this.J))}et(t,s){function e(t,s){const e=s.findIndex((s=>t===s));return s[e===s.length-1?0:e+1]}if(t=[...t],s=[...s],t.length!==s.length)return{isEqual:!1,it:!1};if(t.every(((t,e)=>t===s[e])))return{isEqual:!0,it:!0};const i={isEqual:!1,it:!0};for(const r of t)if(e(r,t)!==e(r,s)){i.it=!1;break}return i.it&&(t[0]===s[1]?i.rt=0:t[1]===s[0]&&(i.rt=t.length-1)),i}nt(t){const{L:s}=this,e=s.findIndex(((s,e,i)=>e===i.length-1||s>=t));s.reverse();return[this.j.size-1-s.findIndex(((s,e,i)=>e===i.length-1||s<=t)),e]}ot({x:s,y:e}){if([s,e].includes(void 0))return!1;const i=this.ht({x:s,y:e});return t._.normalize(-180,180,i)}ct({x:s,y:e}){if([s,e].includes(void 0))return!1;this.ht({x:s,y:e});const i=this.ot({x:s,y:e});if(!1!==i){const[s,e]=this.nt(i);return 0===e||s===e||t._.P([this.L[s],this.L[e]],i)===this.L[e]?e:s}return!1}ut(t){return{...this.lt(this.j.get(t)),slot:this.D.findIndex((s=>s===t))}}yt(t){return[...t??this.D].map((s=>this.ut(s,t).dt))}St(t){return this.D.find((s=>s.gt?.name===t.name))}ft(t){return this.ut(this.St(t))}Pt(t,s=this.D){return s.filter((s=>s!==t))}xt(t,s,e=this.D){return s=s??e.length,[...e.slice(0,s),...[t].flat(),...e.slice(s)]}_t(t){const{slot:s}=this.ut(t);if(~s){const e=[...this.D];return e[s]=new c(t,{parent:this}),e}return!1}wt(t){const{slot:s}=this.ft(t);if(~s){const e=[...this.D];return e[s]=t,e}return!1}async It(t,s=1){const e=[...this.D],i=this.et(e,t);if(i.isEqual)return Promise.resolve();i.it&&"rt"in i&&(t=[e[e.length-1],...e.slice(1,-1),e[0]]),this.O=[...t];const r=this.yt(this.D);return Promise.allSettled(this.D.map(((t,s)=>t.$t(r[s]))))}async kt(t,s){const{slot:e}=this.ut(t);return Number.isInteger(s)?e===s?Promise.resolve():this.It(this.xt(t,s,this.Pt(t))):Promise.reject()}async At(t,s=!1){if(t.$)return Promise.reject();if(this.St(t))return Promise.resolve();const e=this.ct(s?t.P.vt:t),i=new c(t,{parent:this});return this.It(this.xt(i,e,this.Pt(i)))}async Ft(t){const s=this.St(t);return s?this.It(this.Pt(s)).then((()=>s.st())):Promise.reject()}async Tt(t=1,s){const e=[...Array(t)].map((()=>new h({parent:this,type:s})));return this.It(this.xt(e))}async Et(t){this.It(this.Pt(t)),t.st()}async Ct(t){return this.It(this._t(t)).then((()=>this.bt(t)))}bt(s){function e(){const t=this.St(s);t&&this.kt(t,this.ct(s))}this.R.has(s)||(this.R.set(s,e.bind(this)),t.Mt.add(e.bind(this)))}Ut(s){this.R.has(s)&&(t.Mt.remove(this.R.get(s)),this.R.delete(s))}async T(t){return this.At(t).then((()=>this.bt(t))).catch((()=>console.warn(`Could not open snap point for ${t.name}`)))}async F(t){return this.Ut(t),this.Ft(t)}async Wt(s){if(!s.qt)return Promise.reject();const{Dt:e,Ot:i,jt:n}=s.Bt;return this.q(!1),this.Ut(s),this.At(s,!0).then((()=>{const{angle:o}=this.ut(this.St(s)),h=this.Lt({x:i,y:n}),c=r.Nt(o,h),a=e.duration()-e.time(),u=`${c>0?"+":"-"}=${Math.abs(parseInt(c))}`;t.to(this.H,{rotation:u,duration:a,K:"power4.out",V:this,Z(){this.items.forEach((t=>t.tt()))},Rt(){s.$=this,s.tt(),this.It(this.wt(s)),this.q(!0)}})}))}}