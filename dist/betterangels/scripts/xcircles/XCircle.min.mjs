import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,U as r,XElem as h,XItem as n,XDie as o,XSnap as a,MIX as c,HasSnapPath as l}from"../helpers/bundler.mjs";const p=(t.t({name:"slowRotate",effect:(s,e)=>{const[i]=s;return t.to(i.i,{rotation:"+=360",duration:100,repeat:-1,h:"none",paused:!0,o:i,l(){this.p.forEach((t=>t.u?.()))}})},g:{}}),t.S);export default class u extends(c(h).m(l)){static get P(){return{...super.P,$:"pink",A:"yellow",k:"cyan",I:"purple"}}static get v(){return{...super.v,T:[...super.v.T,"x-circle"],M:"xCircle"}}static C({x:s,y:e}){const i=t.R.D({values:Array.from(this.U.keys())},{x:s,y:e}),r=this.U.get(i);return{...i,B:r}}static F(t){return this.C(t).B}constructor(t,s,e,i={}){super($(`\n    <div style="height: ${2*e}px; width: ${2*e}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${e}" cy="${e}" r="${e}" stroke="none"></circle>\n        <path class="motion-path" fill="none" stroke="none" d="m 100 20 c 44.2 0 80 35.8 80 80 c 0 44.2 -35.8 80 -80 80 c -44.2 0 -80 -35.8 -80 -80 c 0 -44.2 35.8 -80 80 -80 z"></path>\n      </svg>\n    </div>`),{properties:{x:t,y:s},L:{x:.8*e,y:.8*e},N:[`x-circle-${i.type??u.v._}`],...i}),this.j(!0)}get p(){return this.G=this.G??[]}get S(){return this.O=this.O??{}}j(t){this.S.X=this.S.X??p.X(this),Boolean(t)!==Boolean(this.S.X.isActive())&&(t?this.S.X.play():this.S.X.pause())}get Y(){return this.q||this.H(),this.q}H(){this.q=new Map;let s=0;this.p.forEach((t=>{s+=t.J,this.q.set(t,s-.5*t.J)}));for(const[e,i]of this.q.entries())this.q.set(e,t.R.normalize(0,s,i))}get K(){return Array.from(this.Y.values())}V(t){return{...this.W(this.Y.get(t)),slot:this.p.findIndex((s=>s===t))}}Z(t){return this.p.find((s=>s instanceof a&&s.tt===t))}st(t){return(t??this.p).map((t=>this.V(t)))}et(t){return this.st(t).map((t=>t.it))}rt(t,s){s=s??{x:t.x,y:t.y};const{it:e}=this.ht(t,s),i=Array.from(this.Y.values()),r=Math.max(0,i.findIndex((t=>t>=e))),h=0===r?this.Y.size-1:r-1;let n=this.K[r],o=this.K[h];for(;n<e;)n++;for(;o>e;)o--;return n-e>e-o?h:r}nt(t,s){return r.ot(s)?this.G=[...this.G.slice(0,s),t,...this.G.slice(s)]:(this.p.push(t),console.log(this.p)),this.H(),t}ct(t,s){s=s??this.p.find((s=>s.tt===t));const e=this.p.findIndex((t=>t===s));if(!r.ot(e))throw new Error(`${s.name} not found in ${this.name}: ${t.name} NOT swapped in.`);return this.p[e]=t,this.H(),s}removeItem(t){if(!this.p.includes(t))throw new Error(`${t.name} not found in ${this.name}`);return this.G=this.p.filter((s=>s!==t)),this.H(),t}lt(t){this.removeItem(t).ut()}async dt(t=.5){const s=this.et();return Promise.allSettled(this.p.map(((e,i)=>e.yt(s[i],t))))}async ft(t=1,s){return[...Array(t)].forEach((()=>this.nt(new o({parent:this,type:s})))),this.dt(5)}async gt(t,s){delete(s=this.ht(t,s)).it,delete s.angle;const e=this.nt(new a(t,{parent:this,properties:s}),this.rt(t,s));return this.dt(.25),e}async wt(s){this.j(!1);const{x:e,y:i}=this.ht(s),r=(this.gt(s),this.xt(s,{x:s.Pt.St,y:s.Pt.$t})),{duration:h}=s.Pt.At;t.to(this.i,{rotation:r,duration:1,h:"expo4.out",o:this,l(){this.p.forEach((t=>t.u?.()))}})}}