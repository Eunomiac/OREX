import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,RoughEase as r,U as h,XElem as n,XItem as o,XDie as a,XSnap as c,MIX as l,HasSnapPath as p}from"../helpers/bundler.mjs";export default class u extends(l(n).t(p)){static get i(){return{...super.i,h:"pink",o:"yellow",l:"cyan",p:"purple"}}static get u(){return{...super.u,g:[...super.u.g,"x-circle"],m:"xCircle"}}static S({x:s,y:e},i){const r=Array.from(this.$.entries()).filter((([t,s])=>i?.name!==s.name)).map((([t])=>t)),h=t.P.v({values:r},{x:s,y:e}),n=this.$.get(h);return{...h,I:n}}static k(t){return this.S(t).I}constructor(t,s,e,i={}){super($(`\n    <div style="height: ${2*e}px; width: ${2*e}px;">\n\t\t\t<video width="200%" height="200%" autoplay muted loop style="left: -50%; top: -50%;">\n\t\t\t\t<source src="https://github.com/Eunomiac/betterangels/blob/master/assets/animations/xcircle-bg3.webm?raw=true" type="video/webm">\n\t\t\t</video>\n      <svg height="100%" width="100%">\n        <path class="circle-path" stroke="none" d="${h.A(e,{x:e,y:e})}"></path>\n        <path class="motion-path" fill="none" stroke="none" d="${h.A(.8*e,{x:e,y:e})}"></path>\n      </svg>\n    </div>`),{properties:{x:t,y:s},T:{x:.8*e,y:.8*e},O:[`x-circle-${i.type??u.u.C}`],...i}),this.D(!0)}get rotation(){return super.rotation}set rotation(t){super.rotation=t,this.M.forEach((t=>t.U?.()))}get M(){return this.B=this.B??[]}get F(){return this.L=this.L??{}}D(s){Boolean(s)!==Boolean(this.N)&&(s?this.N=t.to(this.R,{rotation:"+=360",duration:100,repeat:-1,_:"rough",j:this,G(){this.M.forEach((t=>t.U?.()))}}):(this.N.X(),delete this.N))}get Y(){this.q=new Map;let s=0;this.M.forEach((t=>{s+=t.H,this.q.set(t,s-.5*t.H)}));for(const[e,i]of this.q.entries())this.q.set(e,t.P.normalize(0,s,i));return this.q}get J(){return Array.from(this.Y.values())}K(t){return{...this.V(this.Y.get(t)),slot:this.M.findIndex((s=>s===t))}}W(t){return this.M.find((s=>s instanceof c&&s.Z===t))}tt(t){return(t??this.M).map((t=>this.K(t)))}st(t){return this.tt(t).map((t=>t.et))}it(t,s){s=s??{x:t.x,y:t.y};const{et:e}=this.rt(t,s),i=Array.from(this.Y.values()),r=Math.max(0,i.findIndex((t=>t>=e))),h=0===r?this.Y.size-1:r-1;let n=this.J[r],o=this.J[h];for(;n<e;)n++;for(;o>e;)o--;return n-e>e-o?h:r}ht(t,s){return h.nt(s)?this.B=[...this.B.slice(0,s),t,...this.B.slice(s)]:this.M.push(t),t}ot(t,s){s=s??this.M.find((s=>s.Z===t));const e=this.M.findIndex((t=>t===s));if(h.nt(e))return this.M[e]=t,this.ct===s&&delete this.ct,s;throw new Error(`${s.name} not found in ${this.name}: ${t.name} NOT swapped in.`)}removeItem(t){if(this.M.includes(t))return this.B=this.M.filter((s=>s!==t)),this.ct===t&&delete this.ct,t;throw new Error(`${t.name} not found in ${this.name}`)}lt(t){this.removeItem(t).X()}async ut(t=.5,s){const e=this.st();return Promise.allSettled(this.M.map(((i,r)=>i.dt(e[r],t,s))))}async yt(t=1,s){return[...Array(t)].forEach((()=>this.ht(new a({parent:this,type:s})))),this.ut(5)}async gt(t,s=1){return this.removeItem(t),this.ut(s)}wt(t,s){const{x:e,y:i}=this.rt(t,s),r=new c(t,{parent:this,properties:s});return this.ct=r,this.ht(r,this.it(t,s))}async xt(s){this.D(!1);const e=this.wt(s);await this.ut(.1);const i=h.ft(this.St,e.St,this.St),r=h.ft(this.St,s.$t,this.St),n=h.bt(i,r),o=h.vt(this.rotation+n),a=s.It.Pt.duration(),c=this.rotation>400?-360:360;t.to(this.R,{rotation:o+4*c,duration:a,_:"expo4.inOut",j:this,G(){this.M.forEach((t=>t.U?.()))}}),t.to(`#${this.id} > svg`,{scale:1.5,opacity:.75,rotation:o-2*c,duration:.5*a,_:"sine.inOut"}),t.to(`#${this.id} > svg`,{scale:.5,opacity:1,rotation:o-c,duration:.25*a,delay:.5*a,_:"sine.inOut"}),t.to(`#${this.id} > svg`,{scale:1,rotation:o-c,duration:.25*a,delay:.75*a,_:"sine.inOut"})}async kt(t){this.ot(t).X();this.ut(5,"sine.inOut"),this.D(!0)}}