import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,U as r,XElem as n,XItem as h,XDie as o,XSnap as c,MIX as a,HasSnapPath as u}from"../helpers/bundler.mjs";export default class l extends(a(n).t(u)){static get i(){return{...super.i,h:"pink",o:"yellow",u:"cyan",l:"purple"}}static get p(){return{...super.p,m:[...super.p.m,"x-circle"],S:"xCircle"}}static g({x:s,y:e}){const i=t._.P({values:Array.from(this.I.keys())},{x:s,y:e}),r=this.I.get(i);return{...i,$:r}}static A(t){if(t.P)return t.P;const{x:s,y:e,$:i}=this.g(t.k);return t.v?.name!==i.name&&(t.v?t.v.F(t).then((()=>i.T(t))):i.T(t)),{x:s,y:e,$:i}}static C(t){return this.g(t).$}constructor(t,s,e,i={}){super($(`\n    <div style="height: ${2*e}px; width: ${2*e}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${e}" cy="${e}" r="${e}" stroke="none"></circle>\n        <circle class="motion-path" cx="${e}" cy="${e}" r="${.8*e}" fill="none" stroke="none"></circle>\n      </svg>\n    </div>`),{properties:{x:t,y:s},M:{x:.8*e,y:.8*e},W:[`x-circle-${i.type??l.p.q}`],...i}),this.D(!0)}get O(){return this.U=this.U??[]}get j(){const s=new Map;let e=0;this.O.forEach((t=>{e+=t.L,s.set(t,e-.5*t.L)}));for(const[i,r]of s.entries())s.set(i,t._.normalize(0,e,r));return s}get N(){return Array.from(this.j.values())}get R(){return Array.from(this.j.keys())}get X(){return this.Y=this.Y??new Map}G(s){s?[s].flat().forEach((s=>{t.B(this.H,s),"rotation"===s&&delete this.J})):(t.B(this.H),delete this.J)}D(t){}K(t,s){function e(t,s){const e=s.findIndex((s=>t===s));return s[e===s.length-1?0:e+1]}if(t=[...t],s=[...s],t.length!==s.length)return{isEqual:!1,V:!1};if(t.every(((t,e)=>t===s[e])))return{isEqual:!0,V:!0};const i={isEqual:!1,V:!0};for(const r of t)if(e(r,t)!==e(r,s)){i.V=!1;break}return i.V&&(t[0]===s[1]?i.Z=0:t[1]===s[0]&&(i.Z=t.length-1)),i}tt(t){const{N:s}=this,e=s.findIndex(((s,e,i)=>e===i.length-1||s>=t));s.reverse();return[this.j.size-1-s.findIndex(((s,e,i)=>e===i.length-1||s<=t)),e]}st({x:s,y:e}){if([s,e].includes(void 0))return!1;const i=this.et({x:s,y:e});return t._.normalize(-180,180,i)}it({x:s,y:e}){if([s,e].includes(void 0))return!1;this.et({x:s,y:e});const i=this.st({x:s,y:e});if(!1!==i){const[s,e]=this.tt(i);return 0===e||s===e||t._.P([this.N[s],this.N[e]],i)===this.N[e]?e:s}return!1}rt(t){return{...this.nt(this.j.get(t)),slot:this.O.findIndex((s=>s===t))}}ht(t){return[...t??this.O].map((s=>this.rt(s,t).ot))}ct(t){return this.O.find((s=>s.ut?.name===t.name))}lt(t){return this.rt(this.ct(t))}yt(t,s=this.O){return s.filter((s=>s!==t))}dt(t,s,e=this.O){return s=s??e.length,[...e.slice(0,s),...[t].flat(),...e.slice(s)]}St(t){const{slot:s}=this.rt(t);if(~s){const e=[...this.O];return e[s]=new c(t,{parent:this}),e}return!1}gt(t){const{slot:s}=this.lt(t);if(~s){const e=[...this.O];return e[s]=t,e}return!1}async ft(t,s=1){const e=[...this.O],i=this.K(e,t);if(i.isEqual)return Promise.resolve();i.V&&"Z"in i&&(t=[e[e.length-1],...e.slice(1,-1),e[0]]),this.U=[...t];const r=this.ht(this.O);return Promise.allSettled(this.O.map(((t,s)=>t.Pt(r[s]))))}async xt(t,s){const{slot:e}=this.rt(t);return Number.isInteger(s)?e===s?Promise.resolve():this.ft(this.dt(t,s,this.yt(t))):Promise.reject()}async _t(t,s=!1){if(t.$)return Promise.reject();if(this.ct(t))return Promise.resolve();const e=this.it(s?t.P.wt:t),i=new c(t,{parent:this});return this.ft(this.dt(i,e,this.yt(i)))}async It(t){const s=this.ct(t);return s?this.ft(this.yt(s)).then((()=>s.$t())):Promise.reject()}async At(t=1,s){const e=[...Array(t)].map((()=>new o({parent:this,type:s})));return this.ft(this.dt(e))}async kt(t){this.ft(this.yt(t)),t.$t()}async vt(t){return this.ft(this.St(t)).then((()=>this.Ft(t)))}Ft(s){function e(){const t=this.ct(s);t&&this.xt(t,this.it(s))}this.X.has(s)||(this.X.set(s,e.bind(this)),t.Tt.add(e.bind(this)))}Et(s){this.X.has(s)&&(t.Tt.remove(this.X.get(s)),this.X.delete(s))}async T(t){return this._t(t).then((()=>this.Ft(t))).catch((()=>console.warn(`Could not open snap point for ${t.name}`)))}async F(t){return this.Et(t),this.It(t)}async Ct(s){if(!s.bt)return Promise.reject();const{Mt:e,Wt:i,qt:n}=s.Dt;return this.D(!1),this.Et(s),this._t(s,!0).then((()=>{const{angle:h}=this.rt(this.ct(s)),o=this.Ot({x:i,y:n}),c=r.Ut(h,o),a=e.duration()-e.time(),u=`${c>0?"+":"-"}=${Math.abs(parseInt(c))}`;t.to(this.H,{rotation:u,duration:a,jt:"power4.out",Lt:this,Nt(){this.items.forEach((t=>t.Rt()))},Xt(){s.$=this,s.Rt(),this.ft(this.gt(s)),this.D(!0)}})}))}}