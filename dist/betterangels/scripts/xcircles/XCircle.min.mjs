import{gsap as t,Dragger as e,InertiaPlugin as s,MotionPathPlugin as r,U as i,XElem as n,XItem as h,XDie as o,XSnap as c,MIX as a,HasSnapPath as l}from"../helpers/bundler.mjs";export default class u extends(a(n).t(l)){static get i(){return{...super.i,h:"pink",o:"yellow",l:"cyan",u:"purple"}}static get p(){return{...super.p,g:[...super.p.g,"x-circle"],S:"xCircle"}}static _({x:e,y:s}){const r=t.m.P({values:Array.from(this.A.keys())},{x:e,y:s}),i=this.A.get(r);return{...r,$:i}}static k(t){if(t.P)return t.P;const{x:e,y:s,$:r}=this._(t.v);return t.I?.name!==r.name&&(t.I?t.I.F(t).then((()=>r.T(t))):r.T(t)),{x:e,y:s,$:r}}static C(t){return this._(t).$}constructor(t,e,s,r={}){super($(`\n    <div style="height: ${2*s}px; width: ${2*s}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${s}" cy="${s}" r="${s}" stroke="none"></circle>\n        <circle class="motion-path" cx="${s}" cy="${s}" r="${.8*s}" fill="none" stroke="none"></circle>\n      </svg>\n    </div>`),{properties:{x:t,y:e},M:{x:.8*s,y:.8*s},D:[`x-circle-${r.type??u.p.U}`],...r}),this.j(!0)}get B(){return this.L=this.L??[]}get R(){const e=new Map;let s=0;this.B.forEach((t=>{s+=t.W,e.set(t,s-.5*t.W)}));for(const[r,i]of e.entries())e.set(r,t.m.normalize(0,s,i));return e}get q(){return Array.from(this.R.values())}get G(){return Array.from(this.R.keys())}get N(){return this.O=this.O??new Map}X(e){e?[e].flat().forEach((e=>{t.Y(this.H,e),"rotation"===e&&delete this.J})):(t.Y(this.H),delete this.J)}j(e){Boolean(e)!==Boolean(this.J)&&(e?this.J=t.to(this.H,{rotation:"+=360",duration:100,repeat:-1,K:"none",V:this,Z(){this.B.forEach((t=>t.tt()))}}):(this.J.et(),delete this.J))}st(t,e){return t.length===e.length&&t.every(((t,s)=>t.name===e[s].name))}rt(e,s){if(e.length!==s.length)return!1;const r=s.findIndex((t=>t.name===e[0].name));if(i.it(r)&&e.every(((e,i)=>e.name===t.m.wrap(s,i+r).name))){const t=r-e.length;return Math.abs(t)>=r?r:t}return!1}nt(t){const{q:e}=this,s=e.findIndex(((e,s,r)=>s===r.length-1||e>=t));e.reverse();return[this.R.size-1-e.findIndex(((e,s,r)=>s===r.length-1||e<=t)),s]}ht({x:e,y:s}){if([e,s].includes(void 0))return!1;const r=this.ot({x:e,y:s});return t.m.normalize(-180,180,r)}ct({x:e,y:s}){if([e,s].includes(void 0))return!1;this.ot({x:e,y:s});const r=this.ht({x:e,y:s});if(!1!==r){const[e,s]=this.nt(r);return 0===s||e===s||t.m.P([this.q[e],this.q[s]],r)===this.q[s]?s:e}return!1}lt(t){return{...this.ut(this.R.get(t)),slot:this.B.findIndex((e=>e===t))}}yt(t){return[...t??this.B].map((e=>this.lt(e,t).gt))}dt(t){return this.B.find((e=>e.xt?.name===t.name))}St(t){return this.lt(this.dt(t))}_t(t,e=this.B){return e.filter((e=>e!==t))}Pt(t,e,s=this.B){return e=e??s.length,[...s.slice(0,e),...[t].flat(),...s.slice(e)]}async ft(t,e=1){const s=[...this.B];if(this.st(s,t))return Promise.resolve();!1===this.rt(s,t)||s[0]!==t[1]&&s[1]!==t[0]||(t=[s[s.length-1],...s.slice(1,-1),s[0]]),this.L=[...t];const r=this.yt(this.B);return Promise.allSettled(this.B.map(((t,e)=>t.wt(r[e]))))}async At(t=1,e){const s=[...Array(t)].map((()=>new o({parent:this,type:e})));return this.ft(this.Pt(s))}async $t(t){this.ft(this._t(t)),t.et()}}