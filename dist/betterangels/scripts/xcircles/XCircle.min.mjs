import{gsap as t,Dragger as s,InertiaPlugin as i,MotionPathPlugin as e,RoughEase as r,U as h,XElem as n,XItem as o,XDie as a,XSnap as c,MIX as p,HasSnapPath as l}from"../helpers/bundler.mjs";export default class u extends(p(n).t(l)){static get i(){return{...super.i,h:"pink",o:"yellow",p:"cyan",l:"purple"}}static get u(){return{...super.u,g:[...super.u.g,"x-circle"],S:"xCircle"}}static m({x:s,y:i},e){const r=Array.from(this.$.entries()).filter((([t,s])=>e?.name!==s.name)).map((([t])=>t)),h=t.v.P({values:r},{x:s,y:i}),n=this.$.get(h);return{...h,I:n}}static k(t){return this.m(t).I}constructor(t,s,i,e={}){super($(`\n    <div style="height: ${2*i}px; width: ${2*i}px;">\n      <svg height="100%" width="100%">\n        <path class="circle-path" stroke="none" d="${h.A(i,{x:i,y:i})}"></path>\n        <path class="motion-path" fill="none" stroke="none" d="${h.A(.8*i,{x:i,y:i})}"></path>\n      </svg>\n    </div>`),{properties:{x:t,y:s},T:{x:.8*i,y:.8*i},O:[`x-circle-${e.type??u.u.C}`],...e}),this.D(!0)}get rotation(){return super.rotation}set rotation(t){super.rotation=t,this.M.forEach((t=>t.U?.()))}get M(){return this.B=this.B??[]}get F(){return this.L=this.L??{}}D(s){Boolean(s)!==Boolean(this.N)&&(s?this.N=t.to(this.R,{rotation:"+=360",duration:100,repeat:-1,_:"rough",j:this,G(){this.M.forEach((t=>t.U?.()))}}):(this.N.X(),delete this.N))}get Y(){this.q=new Map;let s=0;this.M.forEach((t=>{s+=t.H,this.q.set(t,s-.5*t.H)}));for(const[i,e]of this.q.entries())this.q.set(i,t.v.normalize(0,s,e));return this.q}get J(){return Array.from(this.Y.values())}K(t){return{...this.V(this.Y.get(t)),slot:this.M.findIndex((s=>s===t))}}W(t){return this.M.find((s=>s instanceof c&&s.Z===t))}tt(t){return(t??this.M).map((t=>this.K(t)))}st(t){return this.tt(t).map((t=>t.it))}et(t,s){s=s??{x:t.x,y:t.y};const{it:i}=this.rt(t,s),e=Array.from(this.Y.values()),r=Math.max(0,e.findIndex((t=>t>=i))),h=0===r?this.Y.size-1:r-1;let n=this.J[r],o=this.J[h];for(;n<i;)n++;for(;o>i;)o--;return n-i>i-o?h:r}ht(t,s){return h.nt(s)?this.B=[...this.B.slice(0,s),t,...this.B.slice(s)]:this.M.push(t),t}ot(t,s){s=s??this.M.find((s=>s.Z===t));const i=this.M.findIndex((t=>t===s));if(h.nt(i))return this.M[i]=t,this.ct===s&&delete this.ct,s;throw new Error(`${s.name} not found in ${this.name}: ${t.name} NOT swapped in.`)}removeItem(t){if(this.M.includes(t))return this.B=this.M.filter((s=>s!==t)),this.ct===t&&delete this.ct,t;throw new Error(`${t.name} not found in ${this.name}`)}lt(t){this.removeItem(t).X()}async ut(t=.5,s){const i=this.st();return Promise.allSettled(this.M.map(((e,r)=>e.dt(i[r],t,s))))}async yt(t=1,s){return[...Array(t)].forEach((()=>this.ht(new a({parent:this,type:s})))),this.ut(5)}async gt(t,s=1){return this.removeItem(t),this.ut(s)}wt(t,s){const{x:i,y:e}=this.rt(t,s),r=new c(t,{parent:this,properties:s});return this.ct=r,this.ht(r,this.et(t,s))}async xt(s){this.D(!1);const i=this.wt(s);await this.ut(.1);const e=h.St(this.ft,i.ft,this.ft),r=h.St(this.ft,s.$t,this.ft),n=h.Pt(e,r),o=h.vt(this.rotation+n),a=s.kt.It.duration(),c=this.rotation>400?-360:360;t.to(this.R,{rotation:o+4*c,duration:a,_:"expo4.inOut",j:this,G(){this.M.forEach((t=>t.U?.()))}}),t.to(`#${this.id} > svg`,{scale:1.5,opacity:.75,rotation:o-2*c,duration:.5*a,_:"sine.inOut"}),t.to(`#${this.id} > svg`,{scale:.5,opacity:1,rotation:o-c,duration:.25*a,delay:.5*a,_:"sine.inOut"}),t.to(`#${this.id} > svg`,{scale:1,rotation:o-c,duration:.25*a,delay:.75*a,_:"sine.inOut"})}async At(t){this.ot(t).X();this.ut(5,"sine.inOut"),this.D(!0)}}