import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,RoughEase as r,U as h,XElem as n,XItem as o,XDie as a,XSnap as p,MIX as c,HasSnapPath as l}from"../helpers/bundler.mjs";export default class u extends(c(n).t(l)){static get i(){return{...super.i,h:"pink",o:"yellow",p:"cyan",l:"purple"}}static get u(){return{...super.u,g:[...super.u.g,"x-circle"],S:"xCircle"}}static m({x:s,y:e},i){const r=Array.from(this.P.entries()).filter((([t,s])=>i?.name!==s.name)).map((([t])=>t)),h=t.I.$({values:r},{x:s,y:e}),n=this.P.get(h);return{...h,k:n}}static A(t){return this.m(t).k}constructor(t,s,e,i={}){super($(`\n    <div style="height: ${2*e}px; width: ${2*e}px;">\n      <svg height="100%" width="100%">\n        <path class="circle-path" stroke="none" d="${h.T(e,{x:e,y:e})}"></path>\n        <path class="motion-path" fill="none" stroke="none" d="${h.T(.8*e,{x:e,y:e})}"></path>\n      </svg>\n    </div>`),{properties:{x:t,y:s},v:{x:.8*e,y:.8*e},M:[`x-circle-${i.type??u.u.C}`],...i}),this.D(!0)}get rotation(){return super.rotation}set rotation(t){super.rotation=t,this.U.forEach((t=>t.B?.()))}get U(){return this.F=this.F??[]}get L(){return this.N=this.N??{}}D(s){Boolean(s)!==Boolean(this.O)&&(s?this.O=t.to(this.R,{rotation:"+=360",duration:100,repeat:-1,_:"rough",j:this,G(){this.U.forEach((t=>t.B?.()))}}):(this.O.X(),delete this.O))}get Y(){return this.q(),this.H}q(){this.H=new Map;let s=0;this.U.forEach((t=>{s+=t.J,this.H.set(t,s-.5*t.J)}));for(const[e,i]of this.H.entries())this.H.set(e,t.I.normalize(0,s,i))}get K(){return Array.from(this.Y.values())}V(t){return{...this.W(this.Y.get(t)),slot:this.U.findIndex((s=>s===t))}}Z(t){return this.U.find((s=>s instanceof p&&s.tt===t))}st(t){return(t??this.U).map((t=>this.V(t)))}et(t){return this.st(t).map((t=>t.it))}rt(t,s){s=s??{x:t.x,y:t.y};const{it:e}=this.ht(t,s),i=Array.from(this.Y.values()),r=Math.max(0,i.findIndex((t=>t>=e))),h=0===r?this.Y.size-1:r-1;let n=this.K[r],o=this.K[h];for(;n<e;)n++;for(;o>e;)o--;return n-e>e-o?h:r}nt(t,s){return h.ot(s)?this.F=[...this.F.slice(0,s),t,...this.F.slice(s)]:this.U.push(t),t}ct(t,s){s=s??this.U.find((s=>s.tt===t));const e=this.U.findIndex((t=>t===s));if(h.ot(e))return this.U[e]=t,this.lt===s&&delete this.lt,s;throw new Error(`${s.name} not found in ${this.name}: ${t.name} NOT swapped in.`)}removeItem(t){if(this.U.includes(t))return this.F=this.U.filter((s=>s!==t)),this.lt===t&&delete this.lt,t;throw new Error(`${t.name} not found in ${this.name}`)}ut(t){this.removeItem(t).X()}async dt(t=.5){const s=this.et();return Promise.allSettled(this.U.map(((e,i)=>e.yt(s[i],t))))}async gt(t=1,s){return[...Array(t)].forEach((()=>this.nt(new a({parent:this,type:s})))),this.dt(5)}async wt(t,s=1){return this.removeItem(t),this.dt(s)}xt(t,s){const{x:e,y:i}=this.ht(t,s),r=new p(t,{parent:this,properties:s});return this.lt=r,this.nt(r,this.rt(t,s))}async St(s){this.D(!1);const e=this.xt(s);await this.dt(.1);const i=h.ft(this.Pt,e.Pt,this.Pt),r=h.ft(this.Pt,s.$t,this.Pt),n=h.It(i,r),o=h.kt(this.rotation+n),a=s.Tt.At.duration();t.to(this.R,{rotation:o+1440,duration:a,_:"expo4.inOut",j:this,G(){this.U.forEach((t=>t.B?.()))}})}async vt(t){const s=this.ct(t);this.dt(.5),this.D(!0),s.X()}}