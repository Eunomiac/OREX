import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,U as r,XElem as n,XItem as h,XDie as o,XSnap as a,MIX as c,HasSnapPath as l}from"../helpers/bundler.mjs";const p=(t.t({name:"slowRotate",effect:(s,e)=>{const[i]=s;return t.to(i.i,{rotation:"+=360",duration:100,repeat:-1,h:"none",paused:!0,o:i,l(){this.p.forEach((t=>t.u?.()))}})},g:{}}),t.S);export default class u extends(c(n).$(l)){static get m(){return{...super.m,P:"pink",A:"yellow",k:"cyan",v:"purple"}}static get I(){return{...super.I,T:[...super.I.T,"x-circle"],M:"xCircle"}}static C({x:s,y:e}){const i=t.R.D({values:Array.from(this.U.keys())},{x:s,y:e}),r=this.U.get(i);return{...i,B:r}}static F(t){return this.C(t).B}constructor(t,s,e,i={}){super($(`\n    <div style="height: ${2*e}px; width: ${2*e}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${e}" cy="${e}" r="${e}" stroke="none"></circle>\n        <circle class="motion-path" cx="${e}" cy="${e}" r="${.8*e}" fill="none" stroke="none"></circle>\n      </svg>\n    </div>`),{properties:{x:t,y:s},L:{x:.8*e,y:.8*e},N:[`x-circle-${i.type??u.I._}`],...i}),this.j(!0)}get p(){return this.G=this.G??[]}get S(){return this.O=this.O??{}}j(t){this.S.X=this.S.X??p.X(this),Boolean(t)!==Boolean(this.S.X.isActive())&&(t?this.S.X.play():this.S.X.pause())}get Y(){return this.q||this.H(),this.q}H(){this.q=new Map;let s=0;this.p.forEach((t=>{s+=t.J,this.q.set(t,s-.5*t.J)}));for(const[e,i]of this.q.entries())this.q.set(e,t.R.normalize(0,s,i))}get K(){return Array.from(this.Y.values())}V(t){return{...this.W(this.Y.get(t)),slot:this.p.findIndex((s=>s===t))}}Z(t){return this.p.find((s=>s instanceof a&&s.tt===t))}st(t){return(t??this.p).map((t=>this.V(t)))}et(t){return this.st(t).map((t=>t.it))}rt({x:t,y:s}){if([t,s].includes(void 0))return!1;const{it:e}=this.nt({x:t,y:s}),i=Array.from(this.Y.values()),r=Math.max(0,i.findIndex((t=>t>=e))),n=0===r?this.Y.size-1:r-1;let h=this.K[r],o=this.K[n];for(;h<e;)h++;for(;o>e;)o--;return h-e>e-o?n:r}ht(t,s){return r.ot(s)?this.G=[...this.G.slice(0,s),t,...this.G.slice(s)]:(this.p.push(t),console.log(this.p)),this.H(),t}ct(t,s){s=s??this.p.find((s=>s.tt===t));const e=this.p.findIndex((t=>t===s));if(!r.ot(e))throw new Error(`${s.name} not found in ${this.name}: ${t.name} NOT swapped in.`);return this.p[e]=t,this.H(),s}removeItem(t){if(!this.p.includes(t))throw new Error(`${t.name} not found in ${this.name}`);return this.G=this.p.filter((s=>s!==t)),this.H(),t}lt(t){this.removeItem(t).ut()}async yt(t=.5){const s=this.et();return Promise.allSettled(this.p.map(((e,i)=>e.dt(s[i],t))))}async xt(t=1,s){return[...Array(t)].forEach((()=>this.ht(new o({parent:this,type:s})))),this.yt(5)}async ft(t,{x:s,y:e}={}){({x:s,y:e}=this.nt(s??t.x,e??t.y));const i=this.ht(new a(t,{parent:this,properties:{x:s,y:e}}),this.rt({x:s,y:e}));return this.yt(.25),i}async gt(s){this.j(!1);const{x:e,y:i}=this.nt(s),n=(this.ft(s),r.wt({x:s.$t.St,y:s.$t.Pt},this)),{duration:h}=s.$t.At;t.to(this.i,{rotation:n,duration:1,h:"expo4.out",o:this,l(){this.p.forEach((t=>t.u?.()))}})}}