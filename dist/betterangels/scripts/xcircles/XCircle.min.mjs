import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,U as r,XElem as n,XItem as o,XDie as h,XSnap as c,MIX as a,HasSnapPath as l}from"../helpers/bundler.mjs";export default class u extends(a(n).t(l)){static get i(){return{...super.i,o:"pink",h:"yellow",l:"cyan",u:"purple"}}static get p(){return{...super.p,_:[...super.p._,"x-circle"],m:"xCircle"}}static S({x:s,y:e}){const i=t.P.g({values:Array.from(this.I.keys())},{x:s,y:e}),r=this.I.get(i);return{...i,$:r}}static A(t,s){if(t.g)return[t.g.$,t.g.k];const{x:e,y:i,$:r}=this.S(s);return t.v?.name!==r.name&&t.v?.F(t).then((()=>r.T(t))),[r,{x:e,y:i}]}static C(t){return this.S(t).$}constructor(t,s,e,i={}){super($(`\n    <div style="height: ${2*e}px; width: ${2*e}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${e}" cy="${e}" r="${e}" stroke="none"></circle>\n        <circle class="motion-path" cx="${e}" cy="${e}" r="${.8*e}" fill="none" stroke="none"></circle>\n      </svg>\n    </div>`),{properties:{x:t,y:s},M:{x:.8*e,y:.8*e},N:[`x-circle-${i.type??u.p.W}`],...i}),this.q(!0)}get D(){return this.O=this.O??[]}get U(){const s=new Map;let e=0;this.D.forEach((t=>{e+=t.j,s.set(t,e-.5*t.j)}));for(const[i,r]of s.entries())s.set(i,t.P.normalize(0,e,r));return s}get G(){return Array.from(this.U.values())}get L(){return Array.from(this.U.keys())}get R(){return this.X=this.X??new Map}Y(s){s?[s].flat().forEach((s=>{t.B(this.H,s),"rotation"===s&&delete this.J})):(t.B(this.H),delete this.J)}q(t){}K(t,s){function e(t,s){const e=s.findIndex((s=>t===s));return s[e===s.length-1?0:e+1]}if(t=[...t],s=[...s],t.length!==s.length)return{isEqual:!1,V:!1};if(t.every(((t,e)=>t===s[e])))return{isEqual:!0,V:!0};const i={isEqual:!1,V:!0};for(const r of t)if(e(r,t)!==e(r,s)){i.V=!1;break}return i.V&&(t[0]===s[1]?i.Z=0:t[1]===s[0]&&(i.Z=t.length-1)),i}tt(t){const{G:s}=this,e=s.findIndex(((s,e,i)=>e===i.length-1||s>=t));s.reverse();return[this.U.size-1-s.findIndex(((s,e,i)=>e===i.length-1||s<=t)),e]}st({x:s,y:e}){if([s,e].includes(void 0))return!1;const i=this.et({x:s,y:e});return t.P.normalize(-180,180,i)}it({x:s,y:e}){if([s,e].includes(void 0))return!1;this.et({x:s,y:e});const i=this.st({x:s,y:e});if(!1!==i){const[s,e]=this.tt(i);return 0===e||s===e||t.P.g([this.G[s],this.G[e]],i)===this.G[e]?e:s}return!1}rt(t){return{...this.nt(this.U.get(t)),slot:this.D.findIndex((s=>s===t))}}ot(t){return[...t??this.D].map((s=>this.rt(s,t).ht))}ct(t){return console.log("=== SNAPPING ==="),console.log(this.D),console.log(t.name),console.log(this.D.map((t=>t.lt?.name))),console.log(this.D.find((s=>s.lt?.name===t.name))),console.log("________________"),this.D.find((s=>s.lt?.name===t.name))}ut(t){return this.rt(this.ct(t))}_t(t,s=this.D){return s.filter((s=>s!==t))}yt(t,s,e=this.D){return s=s??e.length,[...e.slice(0,s),...[t].flat(),...e.slice(s)]}dt(t){const{slot:s}=this.rt(t);if(~s){const e=[...this.D];return e[s]=new c(t,{parent:this}),e}return!1}St(t){const{slot:s}=this.ut(t);if(~s){const e=[...this.D];return e[s]=t,e}return!1}async gt(t,s=1){const e=[...this.D],i=this.K(e,t);if(i.isEqual)return Promise.resolve();i.V&&"Z"in i&&(t=[e[e.length-1],...e.slice(1,-1),e[0]]),this.O=[...t];const r=this.ot(this.D);return Promise.allSettled(this.D.map(((t,s)=>t.Pt(r[s]))))}async ft(t,s){const{slot:e}=this.rt(t);return Number.isInteger(s)?e===s?Promise.resolve():this.gt(this.yt(t,s,this._t(t))):Promise.reject()}async xt(t,s=!1){if(t.$)return Promise.reject();if(this.ct(t))return Promise.resolve();const e=this.it(s?t.g.k:t),i=new c(t,{parent:this});return this.gt(this.yt(i,e,this._t(i)))}async wt(t){const s=this.ct(t);return s?this.gt(this._t(s)).then((()=>s.It())):Promise.reject()}async $t(t=1,s){const e=[...Array(t)].map((()=>new h({parent:this,type:s})));return this.gt(this.yt(e))}async At(t){this.gt(this._t(t)),t.It()}async kt(t){return this.gt(this.dt(t)).then((()=>this.vt(t)))}vt(s){function e(){const t=this.ct(s);t&&this.ft(t,this.it(s))}this.R.has(s)||(this.R.set(s,e.bind(this)),t.Ft.add(e.bind(this)))}Tt(s){this.R.has(s)&&(t.Ft.remove(this.R.get(s)),this.R.delete(s))}async T(t){return this.xt(t).then((()=>this.vt(t))).catch((()=>console.warn(`Could not open snap point for ${t.name}`)))}async F(t){return this.Tt(t),this.wt(t)}async Et(s){if(!s.Ct)return Promise.reject();const{bt:e,Mt:i,Nt:n}=s.Wt;return this.q(!1),this.Tt(s),this.xt(s,!0).then((()=>{const{angle:o}=this.rt(this.ct(s)),h=this.qt({x:i,y:n}),c=r.Dt(o,h),a=e.duration()-e.time(),l=`${c>0?"+":"-"}=${Math.abs(parseInt(c))}`;t.to(this.H,{rotation:l,duration:a,Ot:"power4.out",Ut:this,jt(){this.items.forEach((t=>t.Gt()))},Lt(){s.$=this,s.Gt(),this.gt(this.St(s)),this.q(!0)}})}))}}