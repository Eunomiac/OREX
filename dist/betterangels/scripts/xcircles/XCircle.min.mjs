import{gsap as t,Dragger as s,InertiaPlugin as i,MotionPathPlugin as e,U as r,XElem as n,XItem as h,XDie as o,XSnap as c,MIX as a,BindToXElem as u,HasMotionPath as l,HasSnapPath as p}from"../helpers/bundler.mjs";export default class y extends(a().t(u,p)){static get i(){return this.h=this.h??{}}static get o(){return Object.values(this.i)}static get u(){return{l:"basic",p:"pink",g:"yellow",m:"cyan",S:"purple"}}static get P(){return this.u.l}static get $(){return["x-circle"]}static get _(){return"xCircle"}static get I(){return this.T=this.T??new Map}static A(t){if(t.v.name)t.F=t.v.name;else{const s=`${t.k}_${t.C}`,i=new RegExp(`^${s}_`),e=parseInt(Object.keys(this.i).filter((t=>i.test(t))).pop()?.match(/_(\d+)$/)?.pop()??0)+1;t.F=`${s}_${e}`,t.M=`${t.constructor._}-${t.name}`}}static N(t){return t.O.points.forEach((({x:s,y:i})=>{s=Math.round(s),i=Math.round(i),this.I.set({x:s,y:i},t)})),this.i[t.name]=t,t}static R(t){this.I.forEach(((s,i,e)=>{t===s&&e.delete(i)})),delete this.i[t.name]}static j(t){t.L(),delete this.i[t.name]}static U({x:s,y:i}){const e=t.W.O({values:Array.from(this.I.keys())},{x:s,y:i}),r=this.I.get(e);return console.log(`SNAPPING: {${s}, ${i}} to {${e.x}, ${e.y}} of Circle ${r.type}`),{...e,Y:r}}static q(t,s){if(t.O)return[t.O.Y,t.O.G];const{x:i,y:e,Y:r}=this.U(s);return t.D!==r&&(t.D?.X(t),r.K(t)),[r,{x:i,y:e}]}static B(t){return this.U(t).Y}constructor(t,s,i,e={}){super(),this.v=e,this.type=e.type,this.k=e.H?.id??e.H??r.J(),this.constructor.A(this),this.V(t,s,i),this.constructor.N(this)}get H(){return game.users.get(this.k)}get name(){return this.F}get Z(){return this.tt=this.tt??[]}get st(){const s=new Map;let i=0;this.Z.forEach((t=>{i+=t.it,s.set(t,i-.5*t.it)}));for(const[e,r]of s.entries())s.set(e,t.W.normalize(0,i,r));return s}get et(){return Array.from(this.st.values())}get rt(){return Array.from(this.st.keys())}get nt(){return this.ht=this.ht??new Map}get type(){return this.C}set type(t){const s=this.constructor.u[t]??t??this.constructor.P;if(!Object.values(this.constructor.u).includes(s))throw new Error(`Invalid ${this.constructor.name} Type: ${t}`);this.C=s,this.ot=[]}V(t,s,i){new n(`\n    <div id="${this.id}" class="${this.ct.join(" ")}" style="height: ${2*i}px; width: ${2*i}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${i}" cy="${i}" r="${i}" stroke="none" />\n      </svg>\n    </div>\n    `,{properties:{x:t,y:s},parent:n.ut})}lt(s){s?[s].flat().forEach((s=>{t.yt(this.gt,s),"rotation"===s&&delete this.dt})):(t.yt(this.gt),delete this.dt)}St(t){}ft(t,s){function i(t,s){const i=s.findIndex((s=>t===s));return s[i===s.length-1?0:i+1]}if(t=[...t],s=[...s],t.length!==s.length)return{isEqual:!1,Pt:!1};if(t.every(((t,i)=>t===s[i])))return{isEqual:!0,Pt:!0};const e={isEqual:!1,Pt:!0};for(const r of t)if(i(r,t)!==i(r,s)){e.Pt=!1;break}return e.Pt&&(t[0]===s[1]?e.$t=0:t[1]===s[0]&&(e.$t=t.length-1)),e}_t(t){const{et:s}=this,i=s.findIndex(((s,i,e)=>i===e.length-1||s>=t));s.reverse();return[this.st.size-1-s.findIndex(((s,i,e)=>i===e.length-1||s<=t)),i]}wt({x:s,y:i}){if([s,i].includes(void 0))return!1;const e=this.xt({x:s,y:i});return t.W.normalize(-180,180,e)}It({x:s,y:i}){if([s,i].includes(void 0))return!1;this.xt({x:s,y:i});const e=this.wt({x:s,y:i});if(!1!==e){const[s,i]=this._t(e);return 0===i||s===i||t.W.O([this.et[s],this.et[i]],e)===this.et[i]?i:s}return!1}Tt(t){return{...this.At(this.st.get(t)),slot:this.Z.findIndex((s=>s===t))}}Et(t){return[...t??this.Z].map((s=>this.Tt(s,t).vt))}bt(t){return this.Z.find((s=>s.Ft===t))}kt(t){return this.Tt(this.bt(t))}Ct(t,s=this.Z){return s.filter((s=>s!==t))}Mt(t,s,i=this.Z){return s=s??i.length,[...i.slice(0,s),...[t].flat(),...i.slice(s)]}Nt(t){const s=c.u[[["die",o]].find((([s,i])=>t instanceof i))[0]],{slot:i}=this.Tt(t);if(~i){const e=[...this.Z];return e[i]=new c(t,{Y:this,type:s,Ot:t}),e}return!1}Rt(t){const{slot:s}=this.kt(t);if(~s){const i=[...this.Z];return i[s]=t,i}return!1}async jt(t,s=1){const i=[...this.Z],e=this.ft(i,t);if(e.isEqual)return Promise.resolve();e.Pt&&"$t"in e&&(t=[i[i.length-1],...i.slice(1,-1),i[0]]),this.tt=[...t];const r=this.Et(this.Z);return Promise.allSettled(this.Z.map(((t,s)=>t.Lt(r[s]))))}async Ut(t,s){const{slot:i}=this.Tt(t);return Number.isInteger(s)?i===s?Promise.resolve():this.jt(this.Mt(t,s,this.Ct(t))):Promise.reject()}async Wt(t,s=!1){if(t.Y)return Promise.reject();if(this.bt(t))return Promise.resolve();const i=this.It(s?t.O.G:t),e=new c(t,{Y:this});return this.jt(this.Mt(e,i,this.Ct(e)))}async Yt(t){const s=this.bt(t);return s?this.jt(this.Ct(s)).then((()=>s.qt())):Promise.reject()}async Gt(t=1,s=o.u.l){const i=[...Array(t)].map((()=>new o({Y:this,type:s})));return this.jt(this.Mt(i))}async Dt(t){this.jt(this.Ct(t)),t.qt()}async Xt(t){return this.jt(this.Nt(t)).then((()=>this.Kt(t)))}Kt(s){function i(){const t=this.bt(s);t&&this.Ut(t,this.It(s))}this.nt.has(s)||(this.nt.set(s,i.bind(this)),t.zt.add(i.bind(this)))}Bt(s){this.nt.has(s)&&(t.zt.remove(this.nt.get(s)),this.nt.delete(s))}async K(t){return this.Wt(t).then((()=>this.Kt(t))).catch((()=>console.warn(`Could not open snap point for ${t.name}`)))}async X(t){return this.Bt(t),this.Yt(t)}async Ht(s){if(!s.Jt)return Promise.reject();const{Qt:i,Vt:e,Zt:n}=s.ts;return this.St(!1),this.Bt(s),this.Wt(s,!0).then((()=>{const{angle:h}=this.Tt(this.bt(s)),o=this.ss({x:e,y:n}),c=r.es(h,o),a=i.duration()-i.time(),u=`${c>0?"+":"-"}=${Math.abs(parseInt(c))}`;t.to(this.gt,{rotation:u,duration:a,rs:"power4.out",ns:this,hs(){this.items.forEach((t=>t.os()))},cs(){s.Y=this,s.os(),this.jt(this.Rt(s)),this.St(!0)}})}))}}