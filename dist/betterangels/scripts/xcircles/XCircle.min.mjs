/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */import gsap,{Draggable as Dragger,InertiaPlugin,MotionPathPlugin}from"/scripts/greensock/esm/all.js";import{U,XItem,XDie,XSnap}from"../helpers/bundler.mjs";class XCircle{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get ALL(){return Object.values(this.REGISTRY)}static get TYPES(){return{basic:"basic",pink:"pink",yellow:"yellow",cyan:"cyan",purple:"purple"}}static get CLASSES(){return["x-circle"]}static get PREFIX(){return"xCircle"}static get SNAPPOINTS(){return this._SNAPPOINTS=this._SNAPPOINTS??new Map}static get CONTAINER(){return this._CONTAINER=this._CONTAINER??$("#xContainer")[0]??$('<div id="xContainer" />').appendTo(".vtt.game")[0]}static NameCircle(t){const e=new RegExp(`${t._owner}_${t._type}_`),s=parseInt(Object.keys(this.REGISTRY).filter((t=>e.test(t))).pop()?.match(/_(\d+)$/)?.pop()??0)+1;t._name=`${t._owner}_${t._type}_${s}`}static Register(t){return t.snap.points.forEach((({x:e,y:s})=>{e=Math.round(e),s=Math.round(s),this.SNAPPOINTS.set({x:e,y:s},t)})),this.REGISTRY[t.name]=t,t}static Kill(t){t.killAll(),delete this.REGISTRY[t.name]}static Snap({x:t,y:e}){const s=gsap.utils.snap({values:Array.from(this.SNAPPOINTS.keys())},{x:t,y:e}),i=this.SNAPPOINTS.get(s);return{...s,circle:i}}static GetClosestTo(t){return this.Snap(t).circle}constructor(t,e,s,i){this._owner=i?.owner?.id??i?.owner??U.GMID,this._type=this._checkType(i?.type),this.constructor.NameCircle(this),this._create(t,e,s),this.constructor.Register(this)}get x(){return gsap.getProperty(this.elem,"x")}get y(){return gsap.getProperty(this.elem,"y")}get height(){return gsap.getProperty(this.elem,"height")}get width(){return gsap.getProperty(this.elem,"width")}get radius(){return(this.height+this.width)/4}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return this._id=this._id??`${this.constructor.PREFIX}-${this._name}`}get elem(){return this._elem=this._elem??$(`#${this.id}`)?.[0]}get $(){return $(this.elem)}get defaultClasses(){return[...this.constructor.CLASSES,U.formatAsClass(`${this.constructor.PREFIX}-${this.type}`)]}get snap(){const t=this;return{get id(){return`${t.id}-snap`},get elem(){return t._snapCircle=t._snapCircle??$(`#${this.id}`)?.[0]},get path(){return t._rawSnapPath||(t._rawSnapPath=MotionPathPlugin.getRawPath(this.elem),MotionPathPlugin.cacheRawPathMeasurements(t._rawSnapPath)),t._rawSnapPath},get points(){return new Array(10).fill(null).map(((e,s)=>{const{x:i,y:n}=MotionPathPlugin.convertCoordinates(t.elem,this.constructor.CONTAINER,MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,10,0,1,s)));return{x:i,y:n}}))}}}get slots(){return this._slots=this._slots??[]}get items(){return this.slots.filter((t=>t instanceof XItem))}get readiedItems(){return this._readiedItems=this._readiedItems??[]}get classes(){return this.elem.classList}set classes(t){const e=[...this.defaultClasses,...Array.from([t]).flat().join(" ").trim().split(" ")];this.classes.forEach((t=>{e.includes(t)||this.classes.remove(t)})),t.forEach((t=>this.classes.add(t)))}get type(){return this._type}set type(t){this._type=this._checkType(t),this.classes=[]}get rotation(){return gsap.getProperty(this.elem,"rotation")}set rotation(t){/^[+-]=/.test(`${t}`)&&(t=this.rotation+parseFloat(`${t}`.replace(/=/g,""))),gsap.set(this.elem,{rotation:t})}_create(t,e,s,i=[]){[this._xCircle]=$(`\n    <div id="${this.id}" class="${this.defaultClasses.join(" ")}" style="height: ${2*s}px; width: ${2*s}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${s}" cy="${s}" r="${s}" stroke="none" />\n        <circle id="${this.snap.id}" class="snap-circle" cx="${s}" cy="${s}" r="${.8*s}" fill="none" stroke="none" transform="rotate(90)" />\n      </svg>\n    </div>\n    `).appendTo(XCircle.CONTAINER),this.set({xPercent:-50,yPercent:-50,x:t,y:e}),console.log(this),MotionPathPlugin.convertToPath(`#${this.snap.id}`),this._rawSnapPath=MotionPathPlugin.getRawPath(`#${this.snap.id}`),MotionPathPlugin.cacheRawPathMeasurements(this.snap.path),this._toggleSlowRotate(!0)}_checkType(t){const e=this.constructor.TYPES[t]??t;if(Object.values(this.constructor.TYPES).includes(e))return e;throw new Error(`Invalid Circle Type: ${t}`)}_killTweens(t){t?[t].flat().forEach((t=>{gsap.killTweensOf(this.elem,t),"rotation"===t&&delete this._isSlowRotating})):(gsap.killTweensOf(this.elem),delete this._isSlowRotating)}_toggleSlowRotate(t){}_getAbsAngleTo({x:t,y:e}){return U.getAngle(this,{x:t,y:e})}_getRelAngleTo({x:t,y:e}){return U.cycle(this._getAbsAngleTo({x:t,y:e})-this.rotation+180,-180,180)}_getDistanceTo({x:t,y:e}){return U.getDistance(this,{x:t,y:e})}_getPosOnPath(t){return{pathPos:t,...MotionPathPlugin.getPositionOnPath(this.snap.path,t,!0)}}get slotPathPositions(){let t=0;return this.slots.map((e=>(t+=e.pathWeight,t-.5*e.pathWeight))).map((e=>gsap.utils.mapRange(0,1,0,t,e)))}_getNearestSlot({x:t,y:e}){if([t,e].includes(void 0))return!1;const s=this._getRelAngleTo({x:t,y:e}),i=gsap.utils.normalize(-180,180,s),n=this.slotPathPositions.findIndex(((t,e,s)=>e===s.length-1||t<=i));if(0===n)return n;const a=this.slotPathPositions[n-1];return gsap.utils.snap([this.slotPathPositions[a],this.slotPathPositions[n]],i)===a?a:n}_getItemSlot(t,e,s=!0){let i=-1;return(e=e??(!s&&this.slots))?i=e.findIndex((e=>t instanceof XItem?t.name===e?.name:t===e)):s&&(i=this._getNearestSlot(t)),i>=0&&i}_getItemPos(t,e){const s=this._getItemSlot(t,e);if(!1!==s){const{x:t,y:i,angle:n,pathPos:a}=this._getPosOnPath(s/e.length);return{x:t,y:i,angle:n,pathPos:a,slot:s}}return!1}_getSlotsWithout(t,e){return e=e??[...this.slots],Number.isInteger(parseInt(t))?e.filter(((e,s)=>s!==parseInt(t))):t instanceof XItem?e.filter((e=>!(e instanceof XItem)||e.name!==t.name)):this.slots.filter((e=>e!==t))}_getSlotsPlus(t,e,s){return s=s??[...this.slots],e=e??s.length,[...s.slice(0,e),...[t].flat(),...s.slice(e)]}_compareSlots(t,e){function s(t,e){return t instanceof XItem&&e instanceof XItem?t.name===e.name:t===e}function i(t,e){let i=e.findIndex((e=>s(t,e)));return i===e.length-1?i=0:i++,e[i]}if(t=[...t],e=[...e],t.length!==e.length)return{isEqual:!1,isSameOrder:!1};if(t.every(((t,i)=>s(t,e[i]))))return{isEqual:!0,isSameOrder:!0};const n={isEqual:!1,isSameOrder:!0};for(const a of t)if(!s(i(a,t),i(a,e))){n.isSameOrder=!1;break}return n.isSameOrder&&(s(t[0],e[1])?n.cycleSlot=0:s(t[1],e[0])&&(n.cycleSlot=t.length-1)),n}_checkSlots(t,e){return e=e??this.slots,t instanceof XItem?e.filter((e=>e instanceof XItem&&e.name===t.name)).length>0:e.includes(t)}_getSnap(t,e){if(t instanceof XItem){e=e??this.slots;const s=new RegExp(`xSnap-${t.name}`);return e.find((t=>s.test(t)))}return!1}_checkSnap(t,e){if(e=[...e],t instanceof XItem){const s=`SNAP-${t.name}`,i=e.findIndex((t=>t===s));i>=0&&(e[i]=t)}return e}async pushClockwise(t,e=1){this._getItemSlot(t,this.slots,!1)}async pushCounterClockwise(t,e=1){}async pushToSlot(t,e){}async _distItems(t,e=1,s=!1){const i=[...this.slots];t=Array.isArray(t)?t:this._checkSnap(t,this.slots);const n=this._compareSlots(t,i);if(n.isEqual)return Promise.resolve();n.isSameOrder&&"cycleSlot"in n&&(t=[i[i.length-1],...i.slice(1,-1),i[0]]),this._slots=[...t];const a=Object.fromEntries(this.items.map((t=>[t.id,this._getItemPos(t,i)]))),r=Object.fromEntries(this.items.map((t=>[t.id,this._getItemPos(t,this.slots)]))),o=this;return Promise.allSettled(this.items.map((t=>new Promise(((s,n)=>{let l=a[t.id]?.pathPos??0;const h=r[t.id].pathPos;o._checkSlots(t,i)&&Math.abs(l-h)>.6&&(l>h?l--:l++),console.log(gsap.to(t.elem,{motionPath:{path:o.snap.elem,alignOrigin:[.5,.5],start:l,end:h,fromCurrent:!0},duration:e,ease:"power4.out",onComplete:s,onUpdate(){},onInterrupt:n}))})))))}async _openSnapPoint(t){return t instanceof XItem&&!this._checkSlots(t)?this._distItems(this._getSlotsPlus(new XSnap(t),this._getItemSlot(t))):Promise.reject()}async _closeSnapPoint(t){const e=this._getSnap(t);if(e){const t=this._distItems(this._getSlotsWithout(e));return e.kill(),t}return Promise.reject()}set(t){gsap.set(this.elem,t)}killItem(t){this._distItems(this._getSlotsWithout(t)),t.kill()}killAll(){this.items.forEach(this.killItem),delete this._slots}async addDice(t=1,e=XDie.TYPES.basic){const s=new Array(t).fill(null).map((()=>new XDie({circle:this,type:e})));return this._distItems(this._getSlotsPlus(s))}async pluckItem(t){t instanceof XItem&&this.slots.includes(t)&&(this._distItems(this._getSlotsWithout(t)),this.watchItem(t))}async watchItem(t){console.log(`Readying ${t.name}`),this.readiedItems.filter((e=>t.name===e.name)).length||(this.readiedItems.push(t),console.log("... Readied, Starting Watch"),this.watchItems())}async watchItems(){if(console.log("Watching ..."),this._isWatching)return;this._isWatching=this.readiedItems.length>0;const t=this;let e,s;console.log(`... ${this.readiedItems.length} Items.`),window.requestAnimationFrame((async function i(n){if(t._isWatching&&t.readiedItems.length>0){e=e??n-1e3;const a=n-e;if(s!==n&&Math.floor(a/200)){let e=[...t.slots],s=!1;t.readiedItems.forEach((i=>{const n=`SNAP-${i.name}`,a=t._getItemSlot(i);a!==e.findIndex((t=>t===n))&&(s=!0,e=t._getSlotsPlus(n,a,t._getSlotsWithout(n,e)))})),s&&t._distItems(e,.25)}s=n,window.requestAnimationFrame(i)}else console.log("Nothing to watch."),t._isWatching=!1}))}unwatchItem(t){t instanceof XItem&&(this._readiedItems=this.readiedItems.filter((e=>e.name!==t.name)),this._closeSnapPoint(t))}async distDice(){}async catchItem(t){if(t.isThrowing){this._toggleSlowRotate(!1);const{tween:e,endX:s,endY:i}=t.dragger;this.ping({x:s,y:i});const n=this._getAbsAngleTo({x:s,y:i}),a=`SNAP-${t.name}`,{x:r,y:o}=(this.slots.findIndex((t=>t===a)),this._getItemPos(a,this.slots)),l=this._getAbsAngleTo({x:r,y:o}),h=U.getAngleDelta(l,n);console.log({circle:this,item:t,itemPos:{x:s,y:i,angle:parseInt(n)},snapPos:{x:r,y:o,angle:parseInt(l)},circleAngle:this.rotation,angleDelta:h});const c=e.duration()-e.time(),g=`${h>0?"+":"-"}=${Math.abs(parseInt(h))}`;console.log(g),gsap.to(this.elem,{rotation:g,duration:c,ease:"power4.out",callbackScope:this,onUpdate(){this.items.forEach((t=>t.straighten()))},async onComplete(){t.circle=this,t.straighten(),this._toggleSlowRotate(!0),await this._distItems(t),this.unwatchItem(t)}})}}}export default XCircle;