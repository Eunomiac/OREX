/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */import gsap,{Draggable as Dragger,InertiaPlugin,MotionPathPlugin}from"/scripts/greensock/esm/all.js";import{U,XCircle,XItem,XDie,XSnap}from"./bundler.mjs";class MixinBuilder{constructor(t){this.superclass=t}with(...t){return t.reduce(((t,n=(t=>t))=>n(t)),this.superclass)}}export const MIX=(t=class{})=>new MixinBuilder(t);export const HasMotionPath=t=>class extends t{_getPosOnPath(t){const{x:n,y:e,angle:i}=MotionPathPlugin.getPositionOnPath(this.snap.path,t,!0);return{x:n,y:e,angle:i,pathPos:t}}};export const HasSnapPath=t=>class extends(HasMotionPath(t)){get snap(){const t=this;return{get id(){return`${t.id}-snap`},get elem(){return t._snapCircle=t._snapCircle??$(`#${this.id}`)?.[0]},get path(){return t._rawSnapPath||(t._rawSnapPath=MotionPathPlugin.getRawPath(this.elem),MotionPathPlugin.cacheRawPathMeasurements(t._rawSnapPath)),t._rawSnapPath},get points(){return new Array(t.numSnapPoints).fill(null).map(((n,e)=>{const{x:i,y:s}=MotionPathPlugin.convertCoordinates(t.elem,this.constructor.CONTAINER,MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,t.numSnapPoints,0,1,e)));return{x:i,y:s}}))},get htmlPoints(){return new Array(t.numSnapPoints).fill(null).map(((n,e)=>{const{x:i,y:s}=MotionPathPlugin.convertCoordinates(this.elem,"html",MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,t.numSnapPoints,0,1,e)));return{x:i,y:s}}))},get innPoints(){return new Array(t.numSnapPoints).fill(null).map(((n,e)=>{const{x:i,y:s}=MotionPathPlugin.convertCoordinates(this.elem,this.constructor.CONTAINER,MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,t.numSnapPoints,0,1,e)));return{x:i,y:s}}))},get absPoints(){return new Array(t.numSnapPoints).fill(null).map(((n,e)=>{const{x:i,y:s}=MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,t.numSnapPoints,0,1,e));return{x:i,y:s}}))},get revPoints(){return new Array(t.numSnapPoints).fill(null).map(((n,e)=>{const{x:i,y:s}=MotionPathPlugin.convertCoordinates(this.constructor.CONTAINER,t.elem,MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,t.numSnapPoints,0,1,e)));return{x:i,y:s}}))}}}get numSnapPoints(){return this._numSnapPoints=this._numSnapPoints??10}set numSnapPoints(t){this._numSnapPoints=t}};export const IsDraggable=t=>class extends t{get dragger(){return this._dragger}get isThrowing(){return this.dragger?.isThrowing}get isDragging(){return this._isDragging&&!this.isThrowing}get parent(){return super.parent}set parent(t){super.parent=t,this.dragger?.update(!1,this.isDragging)}get isMoving(){return super.isMoving||this.isDragging||this.isThrowing}set isMoving(t){super.isMoving=t}_create(...t){super._create(...t),this._createDragger()}_onDragStart(){this._isDragging=!0}_onDrag(t){}_onSnap(t){}_onDragEnd(){this._isDragging=!1}_onThrowUpdate(){}_onThrowComplete(){}_createDragger(){[this._dragger]=Dragger.create(this.elem,{type:"x,y",inertia:!0,callbackScope:this,minDuration:2,throwResistance:100,onDragStart:this._onDragStart,onDrag:this._onDrag,snap:{points:this._onSnap},onDragEnd:this._onDragEnd,onThrowUpdate:this._onThrowUpdate,onThrowComplete:this._onThrowComplete})}};export const SnapsToCircle=t=>class extends t{get snap(){if(super.snap)throw new Error(`SnapsToCircle Mixin Collision: Preexisting 'snap' getter on ${super.constructor.name}`);const t=this;return this.circle?null:{get circle(){return t._snapCircle},get x(){return t._snapPoint?.x},get y(){return t._snapPoint?.y},get point(){return{x:this.x,y:this.y}}}}get closestCircle(){return this._closestCircle=this.circle??this.snap?.circle??this._closestCircle??XCircle.GetClosestTo(this)}set closestCircle(t){this._closestCircle=t}get pathPos(){return this._pathPos=!!this.circle&&(this._pathPos??0)}set pathPos(t){this._pathPos=!!this.circle&&t}get pathWeight(){return this._pathWeight=this._pathWeight??this._options.pathWeight??1}set pathWeight(t){this._pathWeight=t}get pathRepositionTime(){return this._pathRepositionTime=this._pathRepositionTime??.5}set pathRepositionTime(t){this._pathRepositionTime=t}get targetPathPos(){return this._targetPathPos=!!this.circle&&(this._targetPathPos??0)}set targetPathPos(t){this._targetPathPos=!!this.circle&&t}async setPathPos(t){if(!this.circle)return Promise.reject();if(t===this.targetPathPos)return Promise.resolve();const n=this;let[e,i]=[this.pathPos,t];return e&&Math.abs(e-i)>.6&&(e+=e>i?-1:1),this.targetPathPos=t,new Promise(((t,s)=>{gsap.to(this.elem,{motionPath:{path:this.circle.snap.elem,alignOrigin:[.5,.5],start:e,end:i,fromCurrent:!0},duration:this.pathRepositionTime,ease:"power4.out",onStart(){n.isMoving=!0},onUpdate(){n.circle?n.pathPos=e+this.ratio*(i-e):(this.kill(),s())},onComplete(){n.pathPos=i,n.isMoving=!1,t()},onInterrupt:s})}))}catch(t){delete this._snapCircle,delete this._snapPoint,this.circle=t}_onDragStart(...t){super._onDragStart(...t),delete this._snapCircle,delete this._snapPoint,this.circle?.pluckItem(this),this.parent=XCircle.CONTAINER}_onDrag(t,...n){super._onDrag(t,...n),[this._snapCircle,this._snapPoint]=XCircle.UpdateCircleWatch(this,t)}_onSnap(t){super._onSnap(t);const{x:n,y:e,circle:i}=XCircle.Snap(t);return this._snapCircle=i,this._snapPoint={x:n,y:e},{x:n,y:e}}};