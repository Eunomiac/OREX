import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,U as r,XElem as n,XCircle as h,XItem as o,XDie as a,XSnap as p}from"./bundler.mjs";class u{constructor(t){this.t=t}i(...t){return t.reduce(((t,s=(t=>t))=>s(t)),this.t)}}export const MIX=(t=class{})=>new u(t);export const HasMotionPath=s=>class extends s{get path(){return this.h}set path(s){if(this.o(s)&&(t.set(s,{p:-50,u:-50,transformOrigin:"50% 50%"}),$(s).attr("id",`${this.id}-motion-path`),[s]=i.g(s)),!(s instanceof SVGPathElement))throw new Error("Failed to create MotionPath: Path element must be a valid SVG element.");this.h={id:`${this.id}-motion-path`,l:s,raw:i.P(s)},i.m(this.path.raw)}constructor(s,{S:e={},...i}={}){super(s,i);const[n]=this.D.find(".motion-path");t.set(n,r.$({...this.constructor.T._,...e},(t=>null!==t))),this.path=n}o(t){return t instanceof SVGElement||$(`<svg>${t.outerHTML}</svg>`).find("*")[0]instanceof SVGElement}C(t){const{x:s,y:e,angle:r}=i.M(this.path.raw,t,!0);return{x:s,y:e,angle:r,I:t}}};export const HasSnapPath=s=>class extends(HasMotionPath(s)){get path(){const s=this;return{...super.path,get points(){return[...Array(s.v)].map(((e,r)=>{const h=s.C(t.V.O(0,s.v,0,1,r)),{x:o,y:a}=i.G(s.l,n.N.l,h);return{x:o,y:a}}))}}}set path(t){super.path=t,this.constructor.U=this}static get U(){return this.A=this.A??new Map}static set U(t){t.path.points.forEach((({x:s,y:e})=>{s=r.H(s),e=r.H(e),this.U.set({x:s,y:e},t)}))}static R(t){this.U.forEach(((s,e,i)=>{t.id===s.id&&i.delete(e)})),super.R(t)}get v(){return this.W=this.W??10}set v(t){this.W=t}};export const IsDraggable=t=>class extends t{get X(){return this.j}get k(){return this.X?.k}get F(){return this.q&&!this.k}get parent(){return super.parent}set parent(t){super.parent=t,this.X?.update()}get B(){return super.B||this.F||this.k}set B(t){super.B=t}constructor(t,s={}){super(t,s),this.J()}K(){this.q=!0}L(t){}Y(t){}Z(){this.q=!1}tt(){}st(){}J(){const t=this;[this.j]=s.create(this.l,{type:"x,y",et:!0,it:this,rt:2,nt:100,ht(){return this.K()},ot(t){return this.L(t)},ut:{points:s=>t.Y(s)},gt(){return this.Z()},ct(){return this.tt()},lt(){return this.st()}})}};export const SnapsToCircle=s=>class extends(IsDraggable(s)){get ut(){if(super.ut)throw new Error(`SnapsToCircle Mixin Collision: Preexisting 'snap' getter on ${super.constructor.name}`);const t=this;return this.Pt?null:{get Pt(){return t.xt},get x(){return t.dt?.x},get y(){return t.dt?.y},get St(){return{x:this.x,y:this.y}}}}get wt(){return this.yt=this.Pt??this.ut?.Pt??h.Dt(this)}set wt(t){this.yt=t}get I(){return this.$t=!!this.Pt&&(this.$t??0)}set I(t){this.$t=!!this.Pt&&t}get _t(){return this.ft=this.ft??this.options._t??1}set _t(t){this.ft=t}get Tt(){return this.Ct=this.Ct??.5}set Tt(t){this.Ct=t}get Mt(){return this.Et=!!this.Pt&&(this.Et??0)}set Mt(t){this.Et=!!this.Pt&&t}async It(s){if(!this.Pt)return Promise.reject();if(s===this.Mt)return Promise.resolve();const e=this;let[i,r]=[this.I,s];return i&&Math.abs(i-r)>.6&&(i+=i>r?-1:1),this.Mt=s,new Promise(((s,n)=>{t.to(this.l,{bt:{path:this.Pt.path.l,vt:[.5,.5],start:i,end:r,Ot:!0},duration:this.Tt,Vt:"power4.out",Gt(){e.B=!0},Nt(){e.Pt?e.I=i+this.ratio*(r-i):(e.B=!1,this.Ut(),n())},At(){e.I=r,e.B=!1,s()},Ht:n})}))}catch(){this.Pt=this.xt,delete this.xt,delete this.dt}K(...t){super.K(...t),delete this.xt,delete this.dt,this.Pt?.Rt(this),this.parent=h.N}L(t,...s){super.L(t,...s),[this.xt,this.dt]=h.Wt(this,t)}Y(t){super.Y(t),console.log(`Snapping ${this.name} at (${r.H(t.x)}, ${r.H(t.y)}) to ...`);const{x:s,y:e,Pt:i}=h.Xt(t);return console.log(`... (${r.H(s)}, ${r.H(e)}) of the ${i?.type?.toUpperCase()} XCircle`),this.xt=i,this.dt={x:s,y:e},{x:s,y:e}}Z(){super.Z(),this.xt.jt(this)}};