import{gsap as t,Dragger as s,InertiaPlugin as e,MotionPathPlugin as i,U as r,XElem as n,XCircle as h,XItem as o,XDie as a,XSnap as p}from"./bundler.mjs";class g{constructor(t){this.t=t}i(...t){return t.reduce(((t,s=(t=>t))=>s(t)),this.t)}}export const MIX=(t=class{})=>new g(t);export const HasMotionPath=s=>class extends s{get path(){return this.h}set path(t){if(this.o(t)&&($(t).attr("id",`${this.id}-motion-path`),[t]=i.p(t)),!(t instanceof SVGPathElement))throw new Error("Failed to create MotionPath: Path element must be a valid SVG element.");this.h={id:`${this.id}-motion-path`,g:t,raw:i.u(t)},i.l(this.path.raw)}constructor(s,{P:e={},...i}={}){super(s,i);const[n]=this.m.find(".motion-path");t.set(n,r.S({...this.constructor.T.D,...e},(t=>null!==t))),this.path=n}o(t){return t instanceof SVGElement||$(`<svg>${t.outerHTML}</svg>`).find("*")[0]instanceof SVGElement}_(t){const{x:s,y:e,angle:r}=i.M(this.path.raw,t,!0);return{x:s,y:e,angle:r,C:t}}};export const HasSnapPath=s=>class extends(HasMotionPath(s)){get path(){const s=this;return{...super.path,get points(){return[...Array(s.I)].map(((e,r)=>{const{x:h,y:o}=i.$(s.parent.g,n.v,s._(t.G.V(0,s.I,0,1,r)));return{x:h,y:o}}))}}}set path(t){super.path=t,this.constructor.N=this}static get N(){return this.O=this.O??new Map}static set N(t){t.path.points.forEach((({x:s,y:e})=>{s=r.U(s,2),e=r.U(e,2),this.N.set({x:s,y:e},t)}))}static A(t){this.N.forEach(((s,e,i)=>{t.id===s.id&&i.delete(e)})),super.A(t)}get I(){return this.H=this.H??10}set I(t){this.H=t}};export const IsDraggable=t=>class extends t{get R(){return this.W}get j(){return this.R?.j}get k(){return this.F&&!this.j}get parent(){return super.parent}set parent(t){super.parent=t,this.R?.update()}get X(){return super.X||this.k||this.j}set X(t){super.X=t}constructor(t,s={}){super(t,s),this.q()}B(){this.F=!0}J(t){}K(t){}L(){this.F=!1}Y(){}Z(){}q(){[this.W]=s.create(this.g,{type:"x,y",tt:!0,st:this,et:2,it:100,rt:this.B,nt:this.J,ht:{points:this.K},ot:this.L,gt:this.Y,ut:this.Z})}};export const SnapsToCircle=s=>class extends(IsDraggable(s)){get ht(){if(super.ht)throw new Error(`SnapsToCircle Mixin Collision: Preexisting 'snap' getter on ${super.constructor.name}`);const t=this;return this.ct?null:{get ct(){return t.lt},get x(){return t.Pt?.x},get y(){return t.Pt?.y},get xt(){return{x:this.x,y:this.y}}}}get dt(){return this.St=this.ct??this.ht?.ct??this.St??h.wt(this)}set dt(t){this.St=t}get C(){return this.yt=!!this.ct&&(this.yt??0)}set C(t){this.yt=!!this.ct&&t}get Dt(){return this.Tt=this.Tt??this.options.Dt??1}set Dt(t){this.Tt=t}get _t(){return this.Mt=this.Mt??.5}set _t(t){this.Mt=t}get ft(){return this.Ct=!!this.ct&&(this.Ct??0)}set ft(t){this.Ct=!!this.ct&&t}async Et(s){if(!this.ct)return Promise.reject();if(s===this.ft)return Promise.resolve();const e=this;let[i,r]=[this.C,s];return i&&Math.abs(i-r)>.6&&(i+=i>r?-1:1),this.ft=s,new Promise(((s,n)=>{t.to(this.g,{It:{path:this.ct.path.g,$t:[.5,.5],start:i,end:r,bt:!0},duration:this._t,vt:"power4.out",Vt(){e.X=!0},Gt(){e.ct?e.C=i+this.ratio*(r-i):(e.X=!1,this.Nt(),n())},Ot(){e.C=r,e.X=!1,s()},Ut:n})}))}catch(t){delete this.lt,delete this.Pt,this.ct=t}B(...t){super.B(...t),delete this.lt,delete this.Pt,this.ct?.At(this),this.parent=h.v}J(t,...s){super.J(t,...s),[this.lt,this.Pt]=h.Ht(this,t)}K(t){super.K(t);const{x:s,y:e,ct:i}=h.Rt(t);return this.lt=i,this.Pt={x:s,y:e},{x:s,y:e}}};