import{gsap as t,Dragger as e,InertiaPlugin as s,MotionPathPlugin as i,U as r,XElem as h,XCircle as n,XItem as o,XDie as a,XSnap as g}from"./bundler.mjs";class u{constructor(t){this.t=t}i(...t){return t.reduce(((t,e=(t=>t))=>e(t)),this.t)}}export const MIX=(t=class{})=>new u(t);export const Positioner=t=>class extends t{h({x:t,y:e}=this,s=h.o,r=this){if(s instanceof h&&r instanceof h)return i.g(r.u,s.u,{x:t,y:e});throw new Error("Can only convert coordinates between two XElem instances.")}};export const BindToXElem=e=>class extends e{l(t){t instanceof h&&(this.p=t)}get(e){return this.m?t.P(this.m.m,e):null}set(e={}){this.m&&t.set(this.m.m,e)}get m(){return this.p}get _(){return this.m?._}get u(){return this.m?.m}get id(){return this.S=this.S??this.m?.id}get D(){return this.m?.D}get selector(){return t=>Array.from(this._?.find(t))}T(){this.m?.T(),super.T?.()}get x(){return this.m?.x}set x(t){this.m&&(this.m.x=t)}get y(){return this.m?.y}set y(t){this.m&&(this.m.y=t)}get C(){return this.m?.C}set C(t){this.m&&(this.m.C=t)}get left(){return this.m?.left}set left(t){this.m&&(this.m.left=t)}get right(){return this.m?.right}set right(t){this.m&&(this.m.right=t)}get top(){return this.m?.top}set top(t){this.m&&(this.m.top=t)}get bottom(){return this.m?.bottom}set bottom(t){this.m&&(this.m.bottom=t)}get height(){return this.m?.height}set height(t){this.m&&(this.m.height=t)}get width(){return this.m?.width}set width(t){this.m&&(this.m.width=t)}get M(){return this.m?.M}set M(t){this.m&&(this.m.M=t)}get rotation(){return this.m?.rotation}set rotation(t){this.m&&(this.m.rotation=t)}A(t){return this.m?.A(t)}X(t){return this.m?.X(t)}$(t){return this.m?.$(t)}get parent(){return this.m?.v}set parent(t){this.m&&(this.m.parent=t)}get R(){return[...this.constructor.H??this.m?.R??[],r.I(`${this.constructor.U}-${this.type??"generic"}`)]}get k(){return this.m?.classList}set k(t){this.m&&(this.m.k=t)}get text(){return this.m?.text}set text(t){this.m&&(this.m.text=t)}get G(){return this.m?.G}set G(t){this.m&&(this.m.G=t)}};export const HasMotionPath=t=>class extends t{get path(){return this.O}set path(t){if(!t.V)throw new Error("Failed to create MotionPath: Path element must be an XElem instance bound to an SVG element.");t.m instanceof SVGPathElement||([t.W]=i.j(t.m)),this.O=t,console.log(t),this.B=i.F(t.m),i.q(this.B)}get J(){return this.B}K(t){const{x:e,y:s,angle:r}=i.L(this.path.m,t,!0);return{x:e,y:s,angle:r,N:t}}};export const HasSnapPath=e=>class extends(HasMotionPath(e)){get Y(){return this.Z=this.Z??10}set Y(t){this.Z=t}get tt(){const e=this;return{get id(){return e.path?.id??`${e.id}-snap`},get path(){return e.path},get m(){return e.path?.m},get raw(){return e.J},get points(){return[...Array(e.Y)].map(((s,r)=>{const{x:n,y:o}=i.g(e.u,h.o,e.K(t.st.et(0,e.Y,0,1,r)));return{x:n,y:o}}))}}}};export const IsDraggable=t=>class extends t{get it(){return this.rt}get ht(){return this.it?.ht}get nt(){return this.ot&&!this.ht}get parent(){return super.parent}set parent(t){super.parent=t,this.it?.update()}get gt(){return super.gt||this.nt||this.ht}set gt(t){super.gt=t}ut(...t){super.ut(...t),this.lt()}ct(){this.ot=!0}dt(t){}xt(t){}Pt(){this.ot=!1}wt(){}yt(){}lt(){[this.rt]=e.create(this.m,{type:"x,y",_t:!0,ft:this,St:2,Dt:100,Tt:this.ct,Ct:this.dt,tt:{points:this.xt},Et:this.Pt,bt:this.wt,Mt:this.yt})}};export const SnapsToCircle=e=>class extends e{get tt(){if(super.tt)throw new Error(`SnapsToCircle Mixin Collision: Preexisting 'snap' getter on ${super.constructor.name}`);const t=this;return this.At?null:{get At(){return t.Xt},get x(){return t.$t?.x},get y(){return t.$t?.y},get vt(){return{x:this.x,y:this.y}}}}get Rt(){return this.Ht=this.At??this.tt?.At??this.Ht??n.It(this)}set Rt(t){this.Ht=t}get N(){return this.Ut=!!this.At&&(this.Ut??0)}set N(t){this.Ut=!!this.At&&t}get kt(){return this.Gt=this.Gt??this.Ot.kt??1}set kt(t){this.Gt=t}get Vt(){return this.Wt=this.Wt??.5}set Vt(t){this.Wt=t}get jt(){return this.Bt=!!this.At&&(this.Bt??0)}set jt(t){this.Bt=!!this.At&&t}async Ft(e){if(!this.At)return Promise.reject();if(e===this.jt)return Promise.resolve();const s=this;let[i,r]=[this.N,e];return i&&Math.abs(i-r)>.6&&(i+=i>r?-1:1),this.jt=e,new Promise(((e,h)=>{t.to(this.m,{qt:{path:this.At.tt.m,zt:[.5,.5],start:i,end:r,Jt:!0},duration:this.Vt,Kt:"power4.out",Lt(){s.gt=!0},Nt(){s.At?s.N=i+this.ratio*(r-i):(this.T(),h())},Qt(){s.N=r,s.gt=!1,e()},Yt:h})}))}catch(t){delete this.Xt,delete this.$t,this.At=t}ct(...t){super.ct(...t),delete this.Xt,delete this.$t,this.At?.Zt(this),this.parent=n.o}dt(t,...e){super.dt(t,...e),[this.Xt,this.$t]=n.te(this,t)}xt(t){super.xt(t);const{x:e,y:s,At:i}=n.ee(t);return this.Xt=i,this.$t={x:e,y:s},{x:e,y:s}}};