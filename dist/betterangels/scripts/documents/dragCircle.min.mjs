/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */import gsap,{Draggable as Dragger,InertiaPlugin,MotionPathPlugin}from"/scripts/greensock/esm/all.js";import U from"../helpers/utilities.mjs";class RollCircle{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get TYPES(){return{basic:"basic"}}static get CONTAINER(){return this._CONTAINER=this._CONTAINER??$("#rollCircleContainer")[0]??this.CreateContainer()}static CreateContainer(){return $('<div id="rollCircleContainer" />').appendTo(".vtt.game")[0]}static Register(e){this.REGISTRY[e.name]=e}static Unregister(e){delete this.REGISTRY[e.name]}static Kill(e){e.killAll(),this.Unregister(e)}constructor(e,t,i,s=[],r){this._x=e,this._y=t,this._r=i,this._cssClasses=["roll-circle",...[s].flat()],this._owner=r?.owner??U.GMID,this._type=r?.type??RollCircle.TYPES.basic;const n=new RegExp(`${this._owner}_${this._type}_`);this._indexNum=Object.keys(RollCircle.REGISTRY).filter((e=>n.test(e))).length+1,this._name=`${this._owner}_${this._type}_${this._indexNum}`,this._shortName=`RC-${this.owner.name}-${this._type}_${this._indexNum}`,this._id=`rollCircle-${this.name}`,RollCircle.Register(this),this._create()}get x(){return this._x}get y(){return this._y}get radius(){return this._r}get height(){return 2*this.radius}get width(){return 2*this.radius}get rotation(){return U.get(this.elem,"rotation")}get type(){return this._type}get owner(){return game.users.get(this._owner)}get name(){return this._name}get shortName(){return this._shortName}get id(){return this._id}get sel(){return`#${this.id}`}get elem(){return this._rollCircle}get snap(){const e=this;return{get id(){return`${e.id}-snap`},get sel(){return`#${e.id}`},get elem(){return e._snapCircle},get path(){return e._rawSnapPath},get point(){return MotionPathPlugin.convertCoordinates(e.elem,RollCircle.CONTAINER,MotionPathPlugin.getPositionOnPath(e.snap.path,0))}}}get diceLine(){return this._childDice=this._childDice??[]}get numSlots(){return this.diceLine.length}get dice(){return this.diceLine.filter((e=>e instanceof OREDie&&e.type!==OREDie.TYPES.openSpace))}get numDice(){return this.dice.length}get numBlanks(){return this.numSlots-this.numDice}_create(){[this._rollCircle]=$(`\n    <div id="${this.id}" class="${this._cssClasses.join(" ")}" style="height: ${this.height}px; width: ${this.width}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${this.radius}" cy="${this.radius}" r="${this.radius}" stroke="none" />\n        <circle id="${this.snap.id}" class="snap-circle" cx="${this.radius}" cy="${this.radius}" r="${.8*this.radius}" fill="none" stroke="none" />\n      </svg>\n    </div>\n    `).appendTo(RollCircle.CONTAINER),MotionPathPlugin.convertToPath(this.snap.sel),[this._snapCircle]=$(this.snap.sel),this._rawSnapPath=MotionPathPlugin.getRawPath(this.snap.sel),MotionPathPlugin.cacheRawPathMeasurements(this.snap.path),this._setCircle({xPercent:-50,yPercent:-50,x:this.x,y:this.y}),this._setSnapCircle({xPercent:-50,yPercent:-50}),this._toggleSlowRotate(!0)}_setCircle(e){U.set(this.elem,e)}_setSnapCircle(e){U.set(this.snap.elem,e)}_toggleSlowRotate(e){e?gsap.to(this.sel,{rotation:"+=360",duration:100,repeat:-1,ease:"none",callbackScope:this,onUpdate(){this.diceLine.forEach((e=>e.straighten()))}}):gsap.killTweensOf(this.sel,"rotation")}_getAngleToDie(e){return U.getAngle({x:this.x,y:this.y},{x:e.x,y:e.y})}_addNewDie(e){e instanceof OREDie&&(this._redistributeDice([...this.diceLine,e]),this._childDice=[...this.diceLine,e],gsap.to(e.sel,{opacity:1,duration:.2,delay:.2}))}_openSnapPoint(){this._redistributeDice(["SNAPPOINT",...this.diceLine])}_closeSnapPoint(){this._redistributeDice(this.diceLine,["SNAPPOINT",...this.diceLine])}_catchThrownDie(e){if(e.isThrowing){const{tween:t}=e.dragger;t.duration(),t.time()}}_pluckDie(e){const t=this._getDieSlot(e),i=[...this.diceLine];t&&(i[t]="BLANK"),this._childDice=[...this.diceLine.filter((t=>t.name!==e.name))],this._redistributeDice(this.diceLine,i)}_deleteDie(e){this._pluckDie(e),e.kill()}_getDieSlot(e,t){let i;if(t=t??this.diceLine,e instanceof OREDie)i=t.findIndex((t=>e.name===t.name));else{if(!(t.filter((t=>t===e)).length<=1))throw new Error(`[${this.shortName}] Multiple '${e?.name??e}' in '[${t.map((e=>e?.name??e)).join(" ")}'`);i=t.findIndex((t=>t===e))}return i>=0&&i}_getPosOnPath(e){const{x:t,y:i,angle:s}=MotionPathPlugin.getPositionOnPath(this.snap.path,e,!0);return{x:t,y:i,angle:s,pathPos:e}}_getDiePos(e,t){t=t??this.diceLine;const i=this._getDieSlot(e,t);if(!1!==i){const{x:e,y:s,angle:r,pathPos:n}=this._getPosOnPath(i/t.length);return{x:e,y:s,angle:r,pathPos:n,slot:i}}return!1}_initDiePos(e){const{x:t,y:i,slot:s}=this._getDiePos(e);e.set({x:t,y:i})}_redistributeDice(e,t){t=t??this.diceLine,e=e??this.diceLine;const i=Object.fromEntries(t.map((e=>[e.id,this._getDiePos(e,t)]))),s=Object.fromEntries(e.map((t=>[t.id,this._getDiePos(t,e)])));e.forEach((e=>{if(e instanceof OREDie){const t=i[e.id]?.pathPos??0,r=s[e.id].pathPos;gsap.to(e.sel,{motionPath:{path:this.snap.sel,alignOrigin:[.5,.5],start:t,end:r,fromCurrent:e.id in i},duration:.2,ease:"power4.inOut"})}}))}set(e){this._setCircle(e)}addDie(e){e instanceof OREDie||this._addNewDie(new OREDie(this,e))}pluckDie(e){if(this.diceLine.includes(e)){const t=this.diceLine.map((t=>t.name===e.name?"BLANK":t)),i=["OPEN",...this.diceLine.filter((t=>t.name!==e.name))];this._redistributeDice(i,t),this._watchDie(e)}}readyForDie(e){this._readyDie?.name!==e.name&&(this._readyDie=e)}unreadyForDie(){}watchDie(e){e.name!==this._watchDie?.name?(this._watchDie=e,gsap.to(this.sel,{rotation:this._getAngleToDie(this._watchDie),duration:.25,ease:"power4.out",onComplete:function(){const e=this;let t,i,s;window.requestAnimationFrame((function r(n){if(e._watchDie?.isDragging){i=!t,t=t??n;const a=n-t;if(i||s!==n&&Math.floor(a/100)){const t=e._getAngleToDie(e._watchDie),i=parseInt(U.getAngleDelta(e.rotation,t));gsap.to(e.sel,{rotation:`${i<0?"-":"+"}=${Math.abs(i)}`,duration:.2,ease:"none"})}s=n,window.requestAnimationFrame(r)}}))},callbackScope:this})):console.log(`Already Watching ${e.name}`)}}class OREDie{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get TYPES(){return{basic:"basic",openSpace:"slot-space"}}static Register(e){this.REGISTRY[e.name]=e}static Unregister(e){delete this.REGISTRY[e.name]}constructor(e,t,i){if(t=t??i?.type??OREDie.TYPES.basic,!Object.values(OREDie.TYPES).includes(t))throw new Error(`Invalid Die Type: ${t}`);this._type=t,this._owner=i?.owner??e.owner.id;const s=new RegExp(`${this._owner}_${this._type}_`);this._name=`${this._owner}_${this._type}_${Object.keys(OREDie.REGISTRY).filter((e=>s.test(e))).length+1}`,OREDie.Register(this),this._create(),this.reparent(e),this._createDragger()}get x(){return U.get(this.elem,"x")}get y(){return U.get(this.elem,"y")}get rotation(){return U.get(this.elem,"rotation")}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return`die-${this.name}`}get elem(){return this._elem}get sel(){return`#${this.id}`}get parent(){this._parent=this._parent??{};const e=this;return{get id(){return e._parent.id},get elem(){return e._parent.elem},get sel(){return e._parent.sel}}}get dragger(){return this._dragger}get isThrowing(){return this.dragger?.isThrowing}get isDragging(){return this._isDragging&&!this.isThrowing}get isMoving(){return this.isDragging||this.isThrowing}get homeCircle(){return this._homeCircle}get type(){return this._type}set type(e){$(this.sel).removeClass(`ore-${this.type}`).addClass(`ore-${e}`),this._type=e}_create(){[this._elem]=$(`<div id="${this.id}" class="ore-die ore-${this.type}">X</div>`).appendTo(RollCircle.CONTAINER),this.set({xPercent:-50,yPercent:-50})}_createDragger(){[this._dragger]=Dragger.create(this.sel,{type:"x,y",inertia:!0,callbackScope:this,onDragStart(){this._isDragging=!0,this.closestCircle=this.homeCircle,this.reparent(RollCircle.CONTAINER),this.closestCircle.watchDie(this)},onDrag(){},onDragEnd(){this._isDragging=!1},snap:{points:e=>e},onThrowUpdate(){},onThrowComplete(e){}})}set(e){U.set(this.sel,e)}kill(){OREDie.Unregister(this),$(this.sel).remove()}straighten(){U.set(this.sel,{rotation:-1*U.get(this.parent.sel,"rotation")})}reparent(e){e instanceof RollCircle?(this._parent={id:e.id,elem:e.elem,sel:e.sel,circle:e},this._homeCircle=e):(this._parent={id:e.id,elem:e,sel:`#${e.id}`},delete this._homeCircle);const{x:t,y:i}=this,s=MotionPathPlugin.convertCoordinates(this.elem,this.parent.elem,{x:t,y:i});$(this.elem).appendTo(this.parent.elem),this.set({x:s.x,y:s.y}),this.straighten(),this.dragger&&this.dragger.update(!1,this.isDragging)}}export default()=>{const e=[];return gsap.registerPlugin(Dragger,InertiaPlugin,MotionPathPlugin),[[15,0,635,314,100,"lime"]].forEach((t=>{const i=t.shift(),s=t.shift(),r=new RollCircle(...t);r.set({rotation:s}),r.dice.forEach((e=>e.straighten()));for(let e=0;e<i;e++)r.addDie();r.dbShow(),r.testTweenTiming(),e.push(r)})),e};