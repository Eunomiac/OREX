/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */import gsap,{Draggable as Dragger,InertiaPlugin,MotionPathPlugin}from"/scripts/greensock/esm/all.js";import U from"../helpers/utilities.mjs";class RollCircle{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get ALL(){return Object.values(this.REGISTRY)}static get SnapPoints(){return Object.values(this._SnapPoints??{}).flat()}static GetClosestTo(t){let e=1/0;return this.ALL.reduce(((i,s)=>{const n=s._getDistanceTo(t);return n<e?(e=n,s):i??s}))}static get TYPES(){return{basic:"basic",purple:"purple"}}static get CONTAINER(){return this._CONTAINER=this._CONTAINER??$("#rollCircleContainer")[0]??this.CreateContainer()}static CreateContainer(){return $('<div id="rollCircleContainer" />').appendTo(".vtt.game")[0]}static NameCircle(t){const e=new RegExp(`${this._owner}_${this._type}_`),i=parseInt(Object.keys(RollCircle.REGISTRY).filter((t=>e.test(t))).pop()?.match(/_(\d+)$/)?.pop()??0)+1;t._name=`${t._owner}_${t._type}_${i}`}static Register(t){return this._SnapPoints=this._SnapPoints??{},this._SnapPoints[t.name]=t.snap.points,this.REGISTRY[t.name]=t}static Unregister(t){delete this.REGISTRY[t.name]}static Kill(t){t.killAll(),this.Unregister(t)}constructor(t,e,i,s){this._owner=s?.owner??U.GMID,this._type=s?.type??RollCircle.TYPES.basic,RollCircle.NameCircle(this),this._id=`rollCircle-${this.name}`,this._create(t,e,i,["roll-circle",`type-${this.type}`]),RollCircle.Register(this)}get x(){return U.get(this.elem,"x")}get y(){return U.get(this.elem,"y")}get height(){return U.get(this.elem,"height")}get width(){return U.get(this.elem,"width")}get radius(){return(this.height+this.width)/4}get type(){return this._type}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return this._id}get elem(){return this._rollCircle=this._rollCircle??$(`#${this.id}`)?.[0]}get snap(){const t=this;return{get id(){return`${t.id}-snap`},get elem(){return t._snapCircle=t._snapCircle??$(`#${this.id}`)?.[0]},get path(){return t._rawSnapPath||(t._rawSnapPath=MotionPathPlugin.getRawPath(this.elem),MotionPathPlugin.cacheRawPathMeasurements(t._rawSnapPath)),t._rawSnapPath},get points(){return new Array(35).fill(null).map(((e,i)=>MotionPathPlugin.convertCoordinates(t.elem,RollCircle.CONTAINER,MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,360,0,36,i)))))}}}get slots(){return this._slots=this._slots??[]}get dice(){return this.slots.filter((t=>t instanceof OREDie))}get readiedDice(){return this._readiedDice=this._readiedDice??[]}get rotation(){return U.get(this.elem,"rotation")}set rotation(t){/^[+-]=/.test(`${t}`)&&(t=this.rotation+parseFloat(`${t}`.replace(/=/g,""))),gsap.set(this.elem,{rotation:t})}_create(t,e,i,s=[]){[this._rollCircle]=$(`\n    <div id="${this.id}" class="${s.join(" ")}" style="height: ${2*i}px; width: ${2*i}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${i}" cy="${i}" r="${i}" stroke="none" />\n        <circle id="${this.snap.id}" class="snap-circle" cx="${i}" cy="${i}" r="${.8*i}" fill="none" stroke="none" />\n      </svg>\n    </div>\n    `).appendTo(RollCircle.CONTAINER),console.log(this),MotionPathPlugin.convertToPath(`#${this.snap.id}`),[this._snapCircle]=$(`#${this.snap.id}`),this._rawSnapPath=MotionPathPlugin.getRawPath(this.snap.elem),MotionPathPlugin.cacheRawPathMeasurements(this.snap.path),this._setCircle({xPercent:-50,yPercent:-50,x:t,y:e}),this._setSnapCircle({xPercent:-50,yPercent:-50}),this._toggleSlowRotate(!0)}_setCircle(t){gsap.set(this.elem,t)}_setSnapCircle(t){gsap.set(this.snap.elem,t)}_killTweens(t){t?[t].flat().forEach((t=>{gsap.killTweensOf(this.elem,t),"rotation"===t&&delete this._isSlowRotating})):(gsap.killTweensOf(this.elem),delete this._isSlowRotating)}_toggleSlowRotate(t){t&&this._isSlowRotating||!t&&!this._isSlowRotating||(t?this._isSlowRotating=gsap.to(this.elem,{rotation:"+=360",duration:100,repeat:-1,ease:"none",callbackScope:this,onUpdate(){this.dice.forEach((t=>t.straighten()))}}):(this._isSlowRotating.kill(),delete this._isSlowRotating))}_getAbsAngleTo({x:t,y:e}){return U.getAngle({x:this.x,y:this.y},{x:t,y:e})}_getRelAngleTo({x:t,y:e}){return U.cycle(this._getAbsAngleTo({x:t,y:e})-this.rotation+180,-180,180)}_getDistanceTo({x:t,y:e}){return U.getDistance({x:this.x,y:this.y},{x:t,y:e})}_getNearestSlot({x:t,y:e}){if([t,e].includes(void 0))return!1;const i=this._getRelAngleTo({x:t,y:e}),s=gsap.utils.normalize(-180,180,i);let n=this.slots.findIndex(((t,e,i)=>e/i.length>=s));return-1===n&&(n=this.slots.length-1),n>0&&n/this.slots.length-s>s-(n-1)/this.slots.length&&n--,n}_getPosOnPath(t){const{x:e,y:i,angle:s}=MotionPathPlugin.getPositionOnPath(this.snap.path,t,!0);return{x:e,y:i,angle:s,pathPos:t}}_getDieSlot(t,e,i=!0){let s=-1;return e?s=e.findIndex((e=>t instanceof OREDie?t.name===e?.name:t===e)):i&&(s=this._getNearestSlot(t)),s>=0&&s}_getDiePos(t,e){const i=this._getDieSlot(t,e);if(!1!==i){const{x:t,y:s,angle:n,pathPos:r}=this._getPosOnPath(i/e.length);return{x:t,y:s,angle:n,pathPos:r,slot:i}}return!1}_getSlotsWithout(t,e){return e=e??[...this.slots],Number.isInteger(parseInt(t))?e.filter(((e,i)=>i!==parseInt(t))):t instanceof OREDie?e.filter((e=>!(e instanceof OREDie)||e.name!==t.name)):this.slots.filter((e=>e!==t))}_getSlotsPlus(t,e,i){return i=i??[...this.slots],e=e??i.length,[...i.slice(0,e),...[t].flat(),...i.slice(e)]}_compareSlots(t,e){function i(t,e){return t instanceof OREDie&&e instanceof OREDie?t.name===e.name:t===e}function s(t,e){let s=e.findIndex((e=>i(t,e)));return s===e.length-1?s=0:s++,e[s]}if(t=[...t],e=[...e],t.length!==e.length)return{isEqual:!1,isSameOrder:!1};if(t.every(((t,s)=>i(t,e[s]))))return{isEqual:!0,isSameOrder:!0};const n={isEqual:!1,isSameOrder:!0};for(const r of t)if(!i(s(r,t),s(r,e))){n.isSameOrder=!1;break}return n.isSameOrder&&(i(t[0],e[1])?n.cycleSlot=0:i(t[1],e[0])&&(n.cycleSlot=t.length-1)),n}_checkSlots(t,e){return t instanceof OREDie?e.filter((e=>e instanceof OREDie&&e.name===t.name)).length>0:e.includes(t)}_checkSnap(t,e){if(e=[...e],t instanceof OREDie){const i=`SNAP-${t.name}`,s=e.findIndex((t=>t===i));s>=0&&(e[s]=t)}return e}async pushClockwise(t,e=1){this._getDieSlot(t,this.slots,!1)}async pushCounterClockwise(t,e=1){}async pushToSlot(t,e){}async _redistributeDice(t,e=1,i=!1){const s=[...this.slots];t=Array.isArray(t)?t:this._checkSnap(t,this.slots);const n=this._compareSlots(t,s);if(n.isEqual)return Promise.resolve();n.isSameOrder&&"cycleSlot"in n&&(t=[s[s.length-1],...s.slice(1,-1),s[0]]),this._slots=[...t];const r=Object.fromEntries(this.dice.map((t=>[t.id,this._getDiePos(t,s)]))),o=Object.fromEntries(this.dice.map((t=>[t.id,this._getDiePos(t,this.slots)]))),l=this;return Promise.allSettled(this.dice.map((t=>new Promise(((i,n)=>{let a=r[t.id]?.pathPos??0;const h=o[t.id].pathPos;l._checkSlots(t,s)&&Math.abs(a-h)>.6&&(a>h?a--:a++),console.log(gsap.to(t.elem,{motionPath:{path:l.snap.elem,alignOrigin:[.5,.5],start:a,end:h,fromCurrent:!0},duration:e,ease:"power4.out",onComplete:i,onUpdate(){},onInterrupt:n}))})))))}async _openSnapPoint(t){if(t instanceof OREDie){const e=`SNAP-${t.name}`,i=this._getDieSlot(t);return this.slots[i]===e?Promise.resolve():this.slots.includes(e)?(await this._closeSnapPoint(t),this._openSnapPoint(t)):this._redistributeDice(this._getSlotsPlus(e,i))}return Promise.reject()}async _closeSnapPoint(t){return"ALL"===t?this._redistributeDice(this.dice):(t instanceof OREDie&&(t=`SNAP-${t.name}`),this.slots.includes(t)?this._redistributeDice(this._getSlotsWithout(t)):Promise.resolve())}set(t){this._setCircle(t)}killDie(t){this._redistributeDice(this._getSlotsWithout(t)),t.kill()}killAll(){this.dice.forEach(this.killDie),delete this._slots}async addDice(t=1){const e=this,i=new Array(t).fill(null).map((()=>new OREDie(e)));return this._redistributeDice(this._getSlotsPlus(i))}async pluckDie(t){t instanceof OREDie&&this.slots.includes(t)&&(this._redistributeDice(this._getSlotsWithout(t)),this.readyDie(t))}async readyDie(t){console.log(`Readying ${t.name}`),this.readiedDice.filter((e=>t.name===e.name)).length||(this.readiedDice.push(t),console.log("... Readied, Starting Watch"),this.watchDice())}async watchDice(){if(console.log("Watching ..."),this._isWatching)return;this._isWatching=this.readiedDice.length>0;const t=this;let e,i;console.log(`... ${this.readiedDice.length} Dice.`),window.requestAnimationFrame((async function s(n){if(t._isWatching&&t.readiedDice.length>0){e=e??n-1e3;const r=n-e;if(i!==n&&Math.floor(r/200)){let e=[...t.slots],i=!1;t.readiedDice.forEach((s=>{const n=`SNAP-${s.name}`,r=t._getDieSlot(s);r!==e.findIndex((t=>t===n))&&(i=!0,e=t._getSlotsPlus(n,r,t._getSlotsWithout(n,e)))})),i&&t._redistributeDice(e,.25)}i=n,window.requestAnimationFrame(s)}else console.log("No dice to watch."),t._isWatching=!1}))}unreadyDie(t){t instanceof OREDie&&(this._readiedDice=this._readiedDice.filter((e=>e.name!==t.name)),this._closeSnapPoint(t))}async distDice(){}async catchDie(t){if(t.isThrowing){this._toggleSlowRotate(!1);const{tween:e,endX:i,endY:s}=t.dragger;this.ping({x:i,y:s});const n=this._getAbsAngleTo({x:i,y:s}),r=`SNAP-${t.name}`,{x:o,y:l}=(this.slots.findIndex((t=>t===r)),this._getDiePos(r,this.slots)),a=this._getAbsAngleTo({x:o,y:l}),h=U.getAngleDelta(a,n);console.log({circle:this,die:t,diePos:{x:i,y:s,angle:parseInt(n)},snapPos:{x:o,y:l,angle:parseInt(a)},circleAngle:this.rotation,angleDelta:h});const c=e.duration()-e.time(),g=`${h>0?"+":"-"}=${Math.abs(parseInt(h))}`;console.log(g),gsap.to(this.elem,{rotation:g,duration:c,ease:"power4.out",callbackScope:this,onUpdate(){this.dice.forEach((t=>t.straighten()))},async onComplete(){t.circle=this,t.straighten(),this._toggleSlowRotate(!0),await this._redistributeDice(t),this.unreadyDie(t)}})}}}class OREDie{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get TYPES(){return{basic:"basic",openSpace:"slot-space"}}static Register(t){this.REGISTRY[t.name]=t}static Unregister(t){delete this.REGISTRY[t.name]}constructor(t,e,i){if(e=e??i?.type??OREDie.TYPES.basic,!Object.values(OREDie.TYPES).includes(e))throw new Error(`Invalid Die Type: ${e}`);this._type=e,this._owner=i?.owner??t.owner.id;const s=new RegExp(`${this._owner}_${this._type}_`);this._name=`${this._owner}_${this._type}_${Object.keys(OREDie.REGISTRY).filter((t=>s.test(t))).length+1}`,OREDie.Register(this),this._create(),this.circle=t,this._createDragger()}get x(){return U.get(this.elem,"x")}get y(){return U.get(this.elem,"y")}get rotation(){return U.get(this.elem,"rotation")}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return`die-${this.name}`}get elem(){return this._elem}get sel(){return`#${this.id}`}get parent(){return this._parent}set parent(t){const[e]=$(`#${t?.id??"noElemFound"}`);if(e){const{x:i,y:s}=MotionPathPlugin.convertCoordinates(this.parent?.elem??this.parent??this.elem,e,{x:this.x,y:this.y});this._parent=t,this.set({x:i,y:s}),$(this.elem).appendTo(e),this.straighten(),this.dragger&&this.dragger.update(!1,this.isDragging)}}get circle(){return this.parent instanceof RollCircle?this.parent:void 0}set circle(t){if(!(t instanceof RollCircle))throw new Error(`'${t}' is not a RollCircle`);this.parent=t}get snapPoints(){return this.circle?.snap.points}get dragger(){return this._dragger}get isThrowing(){return this.dragger?.isThrowing}get isDragging(){return this._isDragging&&!this.isThrowing}get isMoving(){return this.isDragging||this.isThrowing}get homeCircle(){return this._homeCircle}get type(){return this._type}set type(t){$(this.sel).removeClass(`ore-${this.type}`).addClass(`ore-${t}`),this._type=t}_create(){[this._elem]=$(`<div id="${this.id}" class="ore-die ore-${this.type}">X</div>`).appendTo(RollCircle.CONTAINER),this.set({xPercent:-50,yPercent:-50})}_createDragger(){[this._dragger]=Dragger.create(this.elem,{type:"x,y",inertia:!0,callbackScope:this,minDuration:2,throwResistance:100,onDragStart(){this._isDragging=!0,this.closestCircle=this.circle??RollCircle.GetClosestTo(this),this.parent=RollCircle.CONTAINER,this.closestCircle.pluckDie(this)},onDrag(){const t=RollCircle.GetClosestTo(this);t?.name!==this.closestCircle?.name&&(this.closestCircle.unreadyDie(this),this.closestCircle=t,this.closestCircle.readyDie(this))},snap:{get points(){return RollCircle.SnapPoints}},onDragEnd(){this._isDragging=!1;const t=RollCircle.GetClosestTo({x:this.dragger.endX,y:this.dragger.endY});t?.name!==this.closestCircle?.name&&(this.closestCircle.unreadyDie(this),this.closestCircle=t,this.closestCircle.readyDie(this)),this.closestCircle.catchDie(this)}})}set(t){gsap.set(this.elem,t)}kill(){OREDie.Unregister(this),$(`#${this.id}`).remove()}straighten(){this.circle?gsap.set(this.elem,{rotation:-1*this.circle.rotation}):gsap.set(this.elem,{rotation:0})}}export default()=>{const t=[];return gsap.registerPlugin(Dragger,InertiaPlugin,MotionPathPlugin),[[3,45,100,100,100,{type:"lime"}],[7,-45,1370,100,100,{type:"cyan"}],[11,0,100,729,100,{type:"pink"}],[15,270,1370,729,100,{type:"yellow"}],[15,0,635,314,100,{type:"purple"}]].forEach((([e,i,...s])=>{const n=new RollCircle(...s);n.set({rotation:i}),n.addDice(e),t.push(n)})),t};