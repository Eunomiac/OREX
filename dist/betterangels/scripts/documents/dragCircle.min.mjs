/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */import gsap,{Draggable as Dragger,InertiaPlugin,MotionPathPlugin}from"/scripts/greensock/esm/all.js";import U from"../helpers/utilities.mjs";class RollCircle{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get ALL(){return Object.values(this.REGISTRY)}static get SnapPoints(){return Object.values(this._SnapPoints??{}).flat()}static GetClosestTo(t){let e,i=1/0;return this.ALL.forEach((s=>{const n=s._getDistanceTo(t);n<i&&(e=s,i=n)})),e}static get TYPES(){return{basic:"basic",purple:"purple"}}static get CONTAINER(){return this._CONTAINER=this._CONTAINER??$("#rollCircleContainer")[0]??this.CreateContainer()}static CreateContainer(){return $('<div id="rollCircleContainer" />').appendTo(".vtt.game")[0]}static NameCircle(t){const e=new RegExp(`${this._owner}_${this._type}_`),i=parseInt(Object.keys(RollCircle.REGISTRY).filter((t=>e.test(t))).pop()?.match(/_(\d+)$/)?.pop()??0)+1;t._name=`${t._owner}_${t._type}_${i}`}static Register(t){return this._SnapPoints=this._SnapPoints??{},this._SnapPoints[t.name]=t.snap.points,this.REGISTRY[t.name]=t}static Unregister(t){delete this.REGISTRY[t.name]}static Kill(t){t.killAll(),this.Unregister(t)}constructor(t,e,i,s){this._owner=s?.owner??U.GMID,this._type=s?.type??RollCircle.TYPES.basic,RollCircle.NameCircle(this),this._id=`rollCircle-${this.name}`,this._create(t,e,i,["roll-circle",`type-${this.type}`]),RollCircle.Register(this)}get x(){return U.get(this.elem,"x")}get y(){return U.get(this.elem,"y")}get height(){return U.get(this.elem,"height")}get width(){return U.get(this.elem,"width")}get radius(){return(this.height+this.width)/4}get type(){return this._type}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return this._id}get elem(){return this._rollCircle=this._rollCircle??$(`#${this.id}`)?.[0]}get snap(){const t=this;return{get id(){return`${t.id}-snap`},get elem(){return t._snapCircle=t._snapCircle??$(`#${this.id}`)?.[0]},get path(){return t._rawSnapPath||(t._rawSnapPath=MotionPathPlugin.getRawPath(this.elem),MotionPathPlugin.cacheRawPathMeasurements(t._rawSnapPath)),t._rawSnapPath},get points(){return new Array(35).fill(null).map(((e,i)=>MotionPathPlugin.convertCoordinates(t.elem,RollCircle.CONTAINER,MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,360,0,36,i)))))}}}get slots(){return this._slots=this._slots??[]}get dice(){return this.slots.filter((t=>t instanceof OREDie))}get readiedDice(){return this._readiedDice=this._readiedDice??[]}get rotation(){return U.get(this.elem,"rotation")}set rotation(t){/^[+-]=/.test(`${t}`)&&(t=this.rotation+parseFloat(`${t}`.replace(/=/g,""))),U.set(this.elem,{rotation:t})}_create(t,e,i,s=[]){[this._rollCircle]=$(`\n    <div id="${this.id}" class="${s.join(" ")}" style="height: ${2*i}px; width: ${2*i}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${i}" cy="${i}" r="${i}" stroke="none" />\n        <circle id="${this.snap.id}" class="snap-circle" cx="${i}" cy="${i}" r="${.8*i}" fill="none" stroke="none" />\n      </svg>\n    </div>\n    `).appendTo(RollCircle.CONTAINER),console.log(this),MotionPathPlugin.convertToPath(`#${this.snap.id}`),[this._snapCircle]=$(`#${this.snap.id}`),this._rawSnapPath=MotionPathPlugin.getRawPath(this.snap.elem),MotionPathPlugin.cacheRawPathMeasurements(this.snap.path),this._setCircle({xPercent:-50,yPercent:-50,x:t,y:e}),this._setSnapCircle({xPercent:-50,yPercent:-50}),this._toggleSlowRotate(!0)}_setCircle(t){U.set(this.elem,t)}_setSnapCircle(t){U.set(this.snap.elem,t)}_killTweens(t){t?[t].flat().forEach((t=>{gsap.killTweensOf(this.elem,t),"rotation"===t&&delete this._isSlowRotating})):(gsap.killTweensOf(this.elem),delete this._isSlowRotating)}_toggleSlowRotate(t){t&&this._isSlowRotating||!t&&!this._isSlowRotating||(t?this._isSlowRotating=gsap.to(this.elem,{rotation:"+=360",duration:100,repeat:-1,ease:"none",callbackScope:this,onUpdate(){this.dice.forEach((t=>t.straighten()))}}):(this._isSlowRotating.kill(),delete this._isSlowRotating))}_getAbsAngleTo({x:t,y:e}){return U.getAngle({x:this.x,y:this.y},{x:t,y:e})}_getRelAngleTo({x:t,y:e}){return U.cycle(this._getAbsAngleTo({x:t,y:e})-this.rotation+180,-180,180)}_getDistanceTo({x:t,y:e}){return U.getDistance({x:this.x,y:this.y},{x:t,y:e})}_getPosOnPath(t){const{x:e,y:i,angle:s}=MotionPathPlugin.getPositionOnPath(this.snap.path,t,!0);return{x:e,y:i,angle:s,pathPos:t}}_getDieSlot(t,e){let i=-1;if(t instanceof OREDie)if(e)i=e.findIndex((e=>t.name===e?.name));else{const e=this._getRelAngleTo(t),s=gsap.utils.normalize(-180,180,e);i=this.slots.findIndex(((t,e,i)=>e/i.length>=s)),-1===i&&(i=this.slots.length-1),i>0&&i/this.slots.length-s>s-(i-1)/this.slots.length&&i--}return i>=0&&i}_getDiePos(t,e){const i=this._getDieSlot(t,e);if(!1!==i){const{x:t,y:s,angle:n,pathPos:r}=this._getPosOnPath(i/e.length);return{x:t,y:s,angle:n,pathPos:r,slot:i}}return!1}_getSlotsWithout(t,e){return e=e??[...this.slots],Number.isInteger(parseInt(t))?e.filter(((e,i)=>i!==parseInt(t))):t instanceof OREDie?e.filter((e=>!(e instanceof OREDie)||e.name!==t.name)):this.slots.filter((e=>e!==t))}_getSlotsPlus(t,e,i){return i=i??[...this.slots],e=e??i.length,[...i.slice(0,e),...[t].flat(),...i.slice(e)]}async _redistributeDice(t,e=1){if(t.map((t=>t instanceof OREDie?t.name:t)).join("")===this.slots.map((t=>t instanceof OREDie?t.name:t)).join(""))return Promise.resolve();const i=[...this.slots];this._slots=[...t];const s=Object.fromEntries(this.dice.map((t=>[t.id,this._getDiePos(t,i)]))),n=Object.fromEntries(this.dice.map((t=>[t.id,this._getDiePos(t,this.slots)]))),r=this;return Promise.allSettled(this.dice.map((t=>new Promise(((i,o)=>{const a=s[t.id]?.pathPos??0,l=n[t.id].pathPos;gsap.to(t.elem,{motionPath:{path:r.snap.elem,alignOrigin:[.5,.5],start:a,end:l,fromCurrent:t.id in s},duration:e,ease:"power4.out",onComplete:i,onInterrupt:o})})))))}async _openSnapPoint(t){if(t instanceof OREDie){const e=`SNAP-${t.name}`,i=this._getDieSlot(t);return this.slots[i]===e?Promise.resolve():this.slots.includes(e)?(await this._closeSnapPoint(t),this._openSnapPoint(t)):this._redistributeDice(this._getSlotsPlus(e,i))}return Promise.reject()}async _closeSnapPoint(t){return"ALL"===t?this._redistributeDice(this.dice):(t instanceof OREDie&&(t=`SNAP-${t.name}`),this.slots.includes(t)?this._redistributeDice(this._getSlotsWithout(t)):Promise.resolve())}set(t){this._setCircle(t)}killDie(t){this._redistributeDice(this._getSlotsWithout(t)),t.kill()}killAll(){this.dice.forEach(this.killDie),delete this._slots}async addDice(t=1){const e=this,i=new Array(t).fill(null).map((()=>new OREDie(e)));return this._redistributeDice(this._getSlotsPlus(i))}async pluckDie(t){t instanceof OREDie&&this.slots.includes(t)&&(await this._redistributeDice(this._getSlotsWithout(t)),this.readyDie(t))}async readyDie(t){console.log(`Readying ${t.name}`),this.readiedDice.filter((e=>t.name===e.name)).length||(this.readiedDice.push(t),console.log("... Readied, Starting Watch"),this.watchDice())}async watchDice(){if(console.log("Watching ..."),this._isWatching)return;this._isWatching=this.readiedDice.length>0;const t=this;let e,i;console.log(`... ${this.readiedDice.length} Dice.`),window.requestAnimationFrame((async function s(n){if(t._isWatching&&t.readiedDice.length>0){e=e??n-1e3;const r=n-e;if(i!==n&&Math.floor(r/200)){let e=[...t.slots],i=!1;t.readiedDice.forEach((s=>{const n=`SNAP-${s.name}`,r=t._getDieSlot(s);r!==e.findIndex((t=>t===n))&&(i=!0,e=t._getSlotsPlus(n,r,t._getSlotsWithout(n,e)))})),i&&t._redistributeDice(e,.25)}i=n,window.requestAnimationFrame(s)}else console.log("No dice to watch."),t._isWatching=!1}))}unreadyDie(t){t instanceof OREDie&&(this._readiedDice=this._readiedDice.filter((e=>e.name!==t.name)),this._closeSnapPoint(t))}catchDie(t){if(t.isThrowing){const{endX:e,endY:i}=t.dragger}if(t.isThrowing){const{tween:e,endX:i,endY:s}=t.dragger,n=e.duration()-e.time(),r=this._getAbsAngleTo({x:i,y:s});gsap.to(this.elem,{rotation:r,duration:n,ease:"power4.out",callbackScope:this,onUpdate(){this.dice.forEach((t=>t.straighten()))},onComplete(){t.circle=this,t.straighten(),this.unreadyDie(t)}})}}}class OREDie{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get TYPES(){return{basic:"basic",openSpace:"slot-space"}}static Register(t){this.REGISTRY[t.name]=t}static Unregister(t){delete this.REGISTRY[t.name]}constructor(t,e,i){if(e=e??i?.type??OREDie.TYPES.basic,!Object.values(OREDie.TYPES).includes(e))throw new Error(`Invalid Die Type: ${e}`);this._type=e,this._owner=i?.owner??t.owner.id;const s=new RegExp(`${this._owner}_${this._type}_`);this._name=`${this._owner}_${this._type}_${Object.keys(OREDie.REGISTRY).filter((t=>s.test(t))).length+1}`,OREDie.Register(this),this._create(),this.circle=t,this._createDragger()}get x(){return U.get(this.elem,"x")}get y(){return U.get(this.elem,"y")}get rotation(){return U.get(this.elem,"rotation")}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return`die-${this.name}`}get elem(){return this._elem}get sel(){return`#${this.id}`}get parent(){return this._parent}set parent(t){const[e]=$(`#${t?.id??"noElemFound"}`);if(e){this._parent=t;const{x:i,y:s}=MotionPathPlugin.convertCoordinates(this.elem,e,{x:this.x,y:this.y});this.set({x:i,y:s}),$(this.elem).appendTo(e),this.straighten(),this.dragger&&this.dragger.update(!1,this.isDragging)}}get circle(){return this.parent instanceof RollCircle?this.parent:void 0}set circle(t){if(!(t instanceof RollCircle))throw new Error(`'${t}' is not a RollCircle`);this.parent=t}get snapPoints(){return this.circle?.snap.points}get dragger(){return this._dragger}get isThrowing(){return this.dragger?.isThrowing}get isDragging(){return this._isDragging&&!this.isThrowing}get isMoving(){return this.isDragging||this.isThrowing}get homeCircle(){return this._homeCircle}get type(){return this._type}set type(t){$(this.sel).removeClass(`ore-${this.type}`).addClass(`ore-${t}`),this._type=t}_create(){[this._elem]=$(`<div id="${this.id}" class="ore-die ore-${this.type}">X</div>`).appendTo(RollCircle.CONTAINER),this.set({xPercent:-50,yPercent:-50})}_createDragger(){[this._dragger]=Dragger.create(this.elem,{type:"x,y",inertia:!0,callbackScope:this,minDuration:2,throwResistance:100,onDragStart(){this._isDragging=!0,this.closestCircle=this.circle??RollCircle.GetClosestTo(this),this.parent=RollCircle.CONTAINER,this.closestCircle.pluckDie(this)},onDrag(){const t=RollCircle.GetClosestTo(this);t?.name!==this.closestCircle?.name&&(this.closestCircle.unreadyDie(this),this.closestCircle=t,this.closestCircle.readyDie(this))},snap:{get points(){return RollCircle.SnapPoints}},onDragEnd(){this._isDragging=!1;const t=RollCircle.GetClosestTo({x:this.dragger.endX,y:this.dragger.endY});t?.name!==this.closestCircle?.name&&(this.closestCircle.unreadyDie(this),this.closestCircle=t,this.closestCircle.readyDie(this)),this.closestCircle.catchDie(this)}})}set(t){U.set(this.elem,t)}kill(){OREDie.Unregister(this),$(`#${this.id}`).remove()}straighten(){this.circle?U.set(this.elem,{rotation:-1*this.circle.rotation}):U.set(this.elem,{rotation:0})}}export default()=>{const t=[];return gsap.registerPlugin(Dragger,InertiaPlugin,MotionPathPlugin),[[15,0,635,314,100,{type:"purple"}]].forEach((([e,i,...s])=>{const n=new RollCircle(...s);n.set({rotation:i}),n.addDice(e),n.dbShow(),t.push(n)})),t};