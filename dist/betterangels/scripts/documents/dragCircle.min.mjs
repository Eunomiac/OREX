/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */import gsap,{Draggable as Dragger,InertiaPlugin,MotionPathPlugin}from"/scripts/greensock/esm/all.js";import U from"../helpers/utilities.mjs";class RollCircle{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get TYPES(){return{basic:"basic"}}static get CONTAINER(){return this._CONTAINER=this._CONTAINER??$("#rollCircleContainer")[0]??this.CreateContainer()}static CreateContainer(){return $('<div id="rollCircleContainer" />').appendTo(".vtt.game")[0]}static Register(e){this.REGISTRY[e.name]=e,console.log(this.REGISTRY)}static Unregister(e){delete this.REGISTRY[e.name]}static Kill(e){e.killAll(),this.Unregister(e)}constructor(e,t,i,s=[],r){this._x=e,this._y=t,this._r=i,this._cssClasses=["roll-circle",...[s].flat()],this._owner=r?.owner??U.GMID,this._type=r?.type??RollCircle.TYPES.basic;const n=new RegExp(`${this._owner}_${this._type}_`);this._name=`${this._owner}_${this._type}_${Object.keys(RollCircle.REGISTRY).filter((e=>n.test(e))).length+1}`,this._id=`rollCircle-${this.name}`,RollCircle.Register(this),this._create()}get x(){return this._x}get y(){return this._y}get radius(){return this._r}get height(){return 2*this.radius}get width(){return 2*this.radius}get type(){return this._type}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return this._id}get sel(){return`#${this.id}`}get elem(){return this._rollCircle}get snap(){const e=this;return{get id(){return`${e.id}-snap`},get sel(){return`#${this.id}`},get elem(){return e._snapCircle},get path(){return e._rawSnapPath}}}get diceLine(){return this._childDice=this._childDice??[]}get numSlots(){return this.diceLine.length}get dice(){return this.diceLine.filter((e=>e.type!==OREDie.TYPES.openSpace))}get numDice(){return this.dice.length}get numBlanks(){return this.numSlots-this.numDice}_create(){[this._rollCircle]=$(`\n    <div id="${this.id}" class="${this._cssClasses.join(" ")}" style="height: ${this.height}px; width: ${this.width}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${this.radius}" cy="${this.radius}" r="${this.radius}" stroke="none" />\n        <circle id="${this.snap.id}" class="snap-circle" cx="${this.radius}" cy="${this.radius}" r="${.8*this.radius}" fill="none" stroke="none" />\n      </svg>\n    </div>\n    `).appendTo(RollCircle.CONTAINER),MotionPathPlugin.convertToPath(this.snap.sel),[this._snapCircle]=$(this.snap.sel),this._rawSnapPath=MotionPathPlugin.getRawPath(this.snap.sel),MotionPathPlugin.cacheRawPathMeasurements(this.snap.path),this._setCircle({xPercent:-50,yPercent:-50,x:this.x,y:this.y}),this._setSnapCircle({xPercent:-50,yPercent:-50}),this._toggleSlowRotate(!0)}_setCircle(e){U.set(this.elem,e)}_setSnapCircle(e){U.set(this.snap.elem,e)}_toggleSlowRotate(e){e?gsap.to(this.sel,{rotation:"+=360",duration:100,repeat:-1,ease:"none"}):gsap.killTweensOf(this.sel,"rotation")}_addNewDie(e){e instanceof OREDie&&(U.set(e.sel,{opacity:0}),this._redistributeDice([...this.diceLine,e]),this._childDice=[...this.diceLine,e],this._initDiePos(e),gsap.to(e.sel,{opacity:1,duration:1,delay:2}))}_deleteDie(e){if(e instanceof OREDie){const t=this.diceLine.filter((t=>t.name!==e.name));this._redistributeDice([...t]),this._childDice=[...t]}}_getDieSlot(e,t){const i=(t=t??this.diceLine).findIndex((t=>e.name===t.name));return i>=0&&i}_getDiePathPos(e,t){t=t??this.diceLine;const i=this._getDieSlot(e,t);if(!1!==i){const e=i/t.length,{x:s,y:r,angle:n}=MotionPathPlugin.getPositionOnPath(this.snap.path,e,!0);return{x:s,y:r,angle:n,pathPos:e}}throw new Error(`No die '${e}' found in ${this.name}.`)}_getDiePathDelta(e,t){return t.includes(e)?{curPathPos:this.diceLine.includes(e)?this._getDiePathPos(e).pathPos:.01,newPathPos:this._getDiePathPos(e,t).pathPos}:{}}_initDiePos(e){const{x:t,y:i}=this._getDiePathPos(e);gsap.set(e.sel,{x:t,y:i})}_redistributeDice(e){const t=e??this.diceLine;this.diceLine.forEach(((i,s)=>{const{curPathPos:r,newPathPos:n}=this._getDiePathDelta(i,t);n&&gsap.to(i.sel,{motionPath:{path:this.snap.sel,alignOrigin:[.5,.5],start:e?r:.01,end:n,fromCurrent:Boolean(e)},duration:2,ease:"power4.inOut"})}))}addDie(e){e instanceof OREDie||this._addNewDie(new OREDie(this,e))}}class OREDie{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get TYPES(){return{basic:"basic",openSpace:"slot-space"}}static Register(e){this.REGISTRY[e.name]=e}static Unregister(e){delete this.REGISTRY[e.name]}static Kill(e){e.kill(),this.Unregister(e)}constructor(e,t,i){if(this._homeCircle=e,t=t??i?.type??OREDie.TYPES.basic,!Object.values(OREDie.TYPES).includes(t))throw new Error(`Invalid Die Type: ${t}`);this._type=t,this._owner=i?.owner??e.owner.id;const s=new RegExp(`${this._owner}_${this._type}_`);this._name=`${this._owner}_${this._type}_${Object.keys(OREDie.REGISTRY).filter((e=>s.test(e))).length+1}`,OREDie.Register(this),this._create()}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return`die-${this.name}`}get elem(){return this._elem}get sel(){return`#${this.id}`}get dragger(){return this._dragger}get homeCircle(){return this._homeCircle}get type(){return this._type}set type(e){$(this.sel).removeClass(`ore-${this.type}`).addClass(`ore-${e}`),this._type=e}_create(){[this._elem]=$(`<div id="${this.id}" class="ore-die ore-${this.type}"></div>`).appendTo(this.homeCircle.elem),this._setDie({xPercent:-50,yPercent:-50,transformOrigin:"50% 50%"}),this._toggleCounterRotate(!0)}_setDie(e){U.set(this.sel,e)}_setHomeCircle(e){e=e??this.homeCircle}_toggleCounterRotate(e){e?(U.set(this.sel,{rotation:-1*U.get(this.homeCircle.sel,"rotation")}),gsap.to(this.sel,{rotation:"+=360",duration:100,repeat:-1,runBackwards:!0,ease:"none"})):gsap.killTweensOf(this.sel,"rotation")}}export default()=>{const e=[];return gsap.registerPlugin(Dragger,InertiaPlugin,MotionPathPlugin),[[3,100,100,100,"lime"],[9,1370,100,100,"cyan"],[13,735,700,100,"pink"]].forEach((t=>{const i=t.shift(),s=new RollCircle(...t);for(let e=0;e<i;e++)s.addDie();e.push(s)})),e};