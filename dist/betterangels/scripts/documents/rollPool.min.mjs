/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */const PHASES={forming:"FORMING",preRoll:"PREROLL",postRoll:"POSTROLL"};Object.freeze(PHASES);class Roll{constructor(t,e={},r={}){this.data=this._prepareData(e),this.options=r,this.terms=this.constructor.parse(t,this.data),this._dice=[],this._formula=this.constructor.getFormula(this.terms),this._evaluated=!1,this._total=void 0}static MATH_PROXY=new Proxy(Math,{has:()=>!0,get:(t,e)=>e===Symbol.unscopables?void 0:t[e]});static CHAT_TEMPLATE="templates/dice/roll.html";static TOOLTIP_TEMPLATE="templates/dice/tooltip.html";_prepareData(t){return t}get dice(){return this._dice.concat(this.terms.reduce(((t,e)=>(e instanceof DiceTerm?t.push(e):e instanceof PoolTerm&&(t=t.concat(e.dice)),t)),[]))}get formula(){return this.constructor.getFormula(this.terms)}get result(){return this.terms.map((t=>t.total)).join("")}get total(){return this._total}alter(t,e,{multiplyNumeric:r=!1}={}){if(this._evaluated)throw new Error("You may not alter a Roll which has already been evaluated");return this.terms=this.terms.map((a=>a instanceof DiceTerm?a.alter(t,e):(a instanceof NumericTerm&&r&&(a.number*=t),a))),this._formula=this.constructor.getFormula(this.terms),this}clone(){return new this.constructor(this._formula,this.data,this.options)}evaluate({minimize:t=!1,maximize:e=!1,async:r}={}){if(this._evaluated)throw new Error(`The ${this.constructor.name} has already been evaluated and is now immutable`);return this._evaluated=!0,CONFIG.debug.dice&&console.debug(`Evaluating roll with formula ${this.formula}`),(t||e)&&(r=!1),void 0===r&&(console.warn("Roll#evaluate is becoming asynchronous. In the short term you may pass async=true or async=false to evaluation options to nominate your preferred behavior."),r=!1),r?this._evaluate({minimize:t,maximize:e}):this._evaluateSync({minimize:t,maximize:e})}async _evaluate({minimize:t=!1,maximize:e=!1}={}){const r=[];for(let a of this.terms){if(!(a instanceof RollTerm))throw new Error("Roll evaluation encountered an invalid term which was not a RollTerm instance");a.isIntermediate&&(await a.evaluate({minimize:t,maximize:e,async:!0}),this._dice=this._dice.concat(a.dice),a=new NumericTerm({number:a.total,options:a.options})),r.push(a)}this.terms=r,this.terms=this.constructor.simplifyTerms(this.terms);for(let r of this.terms)r._evaluated||await r.evaluate({minimize:t,maximize:e,async:!0});return this._total=this._evaluateTotal(),this}_evaluateSync({minimize:t=!1,maximize:e=!1}={}){this.terms=this.terms.map((r=>{if(!(r instanceof RollTerm))throw new Error("Roll evaluation encountered an invalid term which was not a RollTerm instance");return r.isIntermediate?(r.evaluate({minimize:t,maximize:e,async:!1}),this._dice=this._dice.concat(r.dice),new NumericTerm({number:r.total,options:r.options})):r})),this.terms=this.constructor.simplifyTerms(this.terms);for(let r of this.terms)r._evaluated||r.evaluate({minimize:t,maximize:e,async:!1});return this._total=this._evaluateTotal(),this}_evaluateTotal(){const t=this.terms.map((t=>t.total)).join(" "),e=Roll.safeEval(t);if(!Number.isNumeric(e))throw new Error(game.i18n.format("DICE.ErrorNonNumeric",{formula:this.formula}));return e}roll(t={}){return this.evaluate(t)}reroll(t={}){return this.clone().evaluate(t)}static create(t,e={},r={}){return new(0,CONFIG.Dice.rolls[0])(t,e,r)}static getFormula(t){return t.map((t=>t.formula)).join("")}static safeEval(t){let e;try{e=new Function("sandbox","with (sandbox) { return "+t+"}")(Roll.MATH_PROXY)}catch{e=void 0}if(!Number.isNumeric(e))throw new Error(`Roll.safeEval produced a non-numeric result from expression "${t}"`);return e}static simplifyTerms(t){let e=t.reduce(((t,e)=>{const r=t[t.length-1];if(!(e instanceof OperatorTerm)&&r instanceof StringTerm)return r.term+=e.total,foundry.utils.mergeObject(r.options,e.options),t;const a=r instanceof OperatorTerm;return r&&!a&&e instanceof StringTerm?(e.term=String(r.total)+e.term,foundry.utils.mergeObject(e.options,r.options),t[t.length-1]=e,t):(t.push(e),t)}),[]);return e=e.map((t=>{if(!(t instanceof StringTerm))return t;const e=this._classifyStringTerm(t.formula,{intermediate:!1});return e.options=foundry.utils.mergeObject(t.options,e.options,{inplace:!1}),e})),e[0]instanceof OperatorTerm&&"-"!==e[0].operator&&e.shift(),e[t.length-1]instanceof OperatorTerm&&e.pop(),e}static simulate(t,e=1e4){const r=[...Array(e)].map((e=>new this(t).evaluate().total),[]),a=r.reduce(((t,e)=>(t.total=t.total+e,(null===t.min||e<t.min)&&(t.min=e),(null===t.max||e>t.max)&&(t.max=e),t)),{total:0,min:null,max:null});return a.mean=a.total/e,console.log(`Formula: ${t} | Iterations: ${e} | Mean: ${a.mean} | Min: ${a.min} | Max: ${a.max}`),r}static parse(t,e){if(!t)return[];let r=this.replaceFormulaData(t,e,{missing:"0"}),a=this._splitParentheses(r);return a=a.flatMap((t=>"string"==typeof t?this._splitPools(t):t)),a=a.flatMap((t=>"string"==typeof t?this._splitOperators(t):t)),a=a.map(((t,e)=>this._classifyStringTerm(t,{intermediate:!0,prior:a[e-1],next:a[e+1]}))),a}static replaceFormulaData(t,e,{missing:r,warn:a=!1}={}){let i=new RegExp(/@([a-z.0-9_\-]+)/gi);return t.replace(i,((t,i)=>{let s=foundry.utils.getProperty(e,i);return null==s?(a&&ui.notifications&&ui.notifications.warn(game.i18n.format("DICE.WarnMissingData",{match:t})),void 0!==r?String(r):t):String(s).trim()}))}static validate(t){t=t.replace(/@([a-z.0-9_\-]+)/gi,"1");try{return new this(t).evaluate({async:!1}),!0}catch(t){return!1}}static _splitParentheses(t){return this._splitGroup(t,{openRegexp:ParentheticalTerm.OPEN_REGEXP,closeRegexp:ParentheticalTerm.CLOSE_REGEXP,openSymbol:"(",closeSymbol:")",onClose:t=>{const e=t.open.slice(0,-1),r=t.terms.join(""),a={flavor:t.flavor?t.flavor.slice(1,-1):void 0},i=[];if(e in Math){const t=this._splitMathArgs(r);i.push(new MathTerm({fn:e,terms:t,options:a}))}else e&&i.push(e),i.push(new ParentheticalTerm({term:r,options:a}));return i}})}static _splitMathArgs(t){return t.split(",").reduce(((t,e)=>{if(!(e=e.trim()))return t;if(!t.length)return t.push(e),t;const r=t[t.length-1];return Roll.validate(r)?t.push(e):t[t.length-1]=[r,e].join(","),t}),[])}static _splitPools(t){return this._splitGroup(t,{openRegexp:PoolTerm.OPEN_REGEXP,closeRegexp:PoolTerm.CLOSE_REGEXP,openSymbol:"{",closeSymbol:"}",onClose:t=>{const e=this._splitMathArgs(t.terms.join("")),r=Array.from(t.close.slice(1).matchAll(DiceTerm.MODIFIER_REGEXP)).map((t=>t[0])),a={flavor:t.flavor?t.flavor.slice(1,-1):void 0};return[new PoolTerm({terms:e,modifiers:r,options:a})]}})}static _splitGroup(t,{openRegexp:e,closeRegexp:r,openSymbol:a,closeSymbol:i,onClose:s}={}){let{formula:o,flavors:n}=this._extractFlavors(t);const l=o.replace(e,";$&;").replace(r,";$&;").split(";");let c=[],m=0,u={openIndex:void 0,open:"",terms:[],close:"",closeIndex:void 0,flavor:void 0};const h=t=>{const e=t.match(/%F[0-9]+%/);e&&(u.flavor=this._restoreFlavor(e[0],n),t=t.slice(0,e.index)),u.close=t,u.terms=u.terms.map((t=>this._restoreFlavor(t,n))),c=c.concat(s(u))};for(let t of l)if(t=t.trim(),t)if(t.endsWith(a)&&(m++,1===m))u={open:t,terms:[],close:"",flavor:void 0};else if(m>0){if(t.startsWith(i)&&(m--,0===m)){h(t);continue}u.terms.push(t)}else c.push(t);if(0!==m)throw new Error(`Unbalanced group missing opening ${a} or closing ${i}`);return c=c.reduce(((t,e)=>("string"==typeof e?(e=this._restoreFlavor(e,n),"string"==typeof t[t.length-1]?t[t.length-1]=t[t.length-1]+e:t.push(e)):t.push(e),t)),[]),c}static _splitOperators(t){let{formula:e,flavors:r}=this._extractFlavors(t);return e.replace(OperatorTerm.REGEXP,";$&;").split(";").reduce(((t,e)=>{if(!(e=e.trim()))return t;const a=OperatorTerm.OPERATORS.includes(e);return t.push(a?new OperatorTerm({operator:e}):this._restoreFlavor(e,r)),t}),[])}static _extractFlavors(t){const e={};let r=0;return{formula:t=t.replace(RollTerm.FLAVOR_REGEXP,(t=>{let a=`%F${r++}%`;return e[a]=t,a})),flavors:e}}static _restoreFlavor(t,e){for(let[r,a]of Object.entries(e))-1!==t.indexOf(r)&&(delete e[r],t=t.replace(r,a));return t}static _classifyStringTerm(t,{intermediate:e=!0,prior:r,next:a}={}){if(t instanceof RollTerm)return t;const i=NumericTerm.matchTerm(t);if(i)return NumericTerm.fromMatch(i);const s=DiceTerm.matchTerm(t,{imputeNumber:!e});return s?e&&(r?.isIntermediate||a?.isIntermediate)?new StringTerm({term:t}):DiceTerm.fromMatch(s):new StringTerm({term:t})}async getTooltip(){const t=this.dice.map((t=>t.getTooltipData()));return renderTemplate(this.constructor.TOOLTIP_TEMPLATE,{parts:t})}async render(t={}){const e=(t=foundry.utils.mergeObject({user:game.user.id,flavor:null,template:this.constructor.CHAT_TEMPLATE,blind:!1},t)).isPrivate;this._evaluated||this.evaluate();const r={formula:e?"???":this._formula,flavor:e?null:t.flavor,user:t.user,tooltip:e?"":await this.getTooltip(),total:e?"?":Math.round(100*this.total)/100};return renderTemplate(t.template,r)}async toMessage(t={},{rollMode:e,create:r=!0}={}){this._evaluated||await this.evaluate({async:!0}),(t=foundry.utils.mergeObject({user:game.user.id,type:CONST.CHAT_MESSAGE_TYPES.ROLL,content:this.total,sound:CONFIG.sounds.dice},t)).roll=this;const a=getDocumentClass("ChatMessage"),i=new a(t);return e&&i.applyRollMode(e),r?a.create(i.data,{rollMode:e}):i.data}static async expandInlineResult(t){if(!t.classList.contains("inline-roll"))return;if(t.classList.contains("expanded"))return;const e=Roll.fromJSON(unescape(t.dataset.roll)),r=document.createElement("div");r.innerHTML=await e.getTooltip();const a=r.children[0];t.appendChild(a),t.classList.add("expanded");const i=t.getBoundingClientRect(),s=a.getBoundingClientRect();a.style.left=`${Math.min(i.x,window.innerWidth-(s.width+3))}px`,a.style.top=`${Math.min(i.y+i.height+3,window.innerHeight-(s.height+3))}px`;const o=getComputedStyle(t).zIndex;a.style.zIndex=Number.isNumeric(o)?o+1:100}static collapseInlineResult(t){if(!t.classList.contains("inline-roll"))return;if(!t.classList.contains("expanded"))return;const e=t.querySelector(".dice-tooltip");return e&&e.remove(),t.classList.remove("expanded")}toJSON(){return{class:this.constructor.name,options:this.options,dice:this._dice,formula:this._formula,terms:this.terms,total:this._total,evaluated:this._evaluated}}static fromData(t){const e=new this(t.formula,t.data,t.options);return e.terms=t.terms.map((t=>t.class?("DicePool"===t.class&&(t.class="PoolTerm"),RollTerm.fromData(t)):t)),(t.evaluated??1)&&(e._total=t.total,e._dice=(t.dice||[]).map((t=>DiceTerm.fromData(t))),e._evaluated=!0),e}static fromJSON(t){const e=JSON.parse(t),r=CONFIG.Dice.rolls.find((t=>t.name===e.class));if(!r)throw new Error(`Unable to recreate ${e.class} instance from provided data`);return r.fromData(e)}static fromTerms(t,e={}){if(!t.every((t=>t instanceof RollTerm)))throw new Error("All provided terms must be RollTerm instances");const r=t.every((t=>t._evaluated)),a=!t.some((t=>t._evaluated));if(!r&&!a)throw new Error("You can only call Roll.fromTerms with an array of terms which are either all evaluated, or none evaluated");const i=this.getFormula(t),s=this.create(i,{},e);return s.terms=t,s._evaluated=r,s._evaluated&&(s._total=s._evaluateTotal()),s}get _rolled(){return console.warn("You are referencing Roll#_rolled which is deprecated in favor of Roll#_evaluated"),this._evaluated}}export default class extends Roll{static get PHASES(){return PHASES}constructor(...t){const e=t.pop();super(...t,e),this.phase=PHASES.forming,this.render()}get phase(){return this._phase}set phase(t){if(!(t in PHASES))throw new Error(`'${t}' is not a phase: ${Object.keys(PHASES).join(", ")}`);this._phase=t}}