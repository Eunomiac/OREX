/* ▌██░░ betterangels v0.0.1-prealpha (2021) ║ MIT License ║ https://github.com/Eunomiac/betterangels ░░██▐ */import gsap,{Draggable as Dragger,InertiaPlugin,MotionPathPlugin}from"/scripts/greensock/esm/all.js";import U from"../helpers/utilities.mjs";class RollCircle{static get REGISTRY(){return this._REGISTRY=this._REGISTRY??{}}static get ALL(){return Object.values(this.REGISTRY)}static get SnapPoints(){return Object.values(this._SnapPoints??{}).flat()}static GetClosestTo(t){let e=1/0;return this.ALL.reduce(((i,s)=>{const n=s._getDistanceTo(t);return n<e?(e=n,s):i??s}))}static get TYPES(){return{basic:"basic",purple:"purple"}}static get CONTAINER(){return this._CONTAINER=this._CONTAINER??$("#rollCircleContainer")[0]??this.CreateContainer()}static CreateContainer(){return $('<div id="rollCircleContainer" />').appendTo(".vtt.game")[0]}static NameCircle(t){const e=new RegExp(`${this._owner}_${this._type}_`),i=parseInt(Object.keys(RollCircle.REGISTRY).filter((t=>e.test(t))).pop()?.match(/_(\d+)$/)?.pop()??0)+1;t._name=`${t._owner}_${t._type}_${i}`}static Register(t){return this._SnapPoints=this._SnapPoints??{},this._SnapPoints[t.name]=t.snap.points,this.REGISTRY[t.name]=t}static Unregister(t){delete this.REGISTRY[t.name]}static Kill(t){t.killAll(),this.Unregister(t)}constructor(t,e,i,s){this._owner=s?.owner??U.GMID,this._type=s?.type??RollCircle.TYPES.basic,RollCircle.NameCircle(this),this._id=`rollCircle-${this.name}`,this._create(t,e,i,["roll-circle",`type-${this.type}`]),RollCircle.Register(this)}get x(){return gsap.getProperty(this.elem,"x")}get y(){return gsap.getProperty(this.elem,"y")}get height(){return gsap.getProperty(this.elem,"height")}get width(){return gsap.getProperty(this.elem,"width")}get radius(){return(this.height+this.width)/4}get type(){return this._type}get owner(){return game.users.get(this._owner)}get name(){return this._name}get id(){return this._id}get elem(){return this._rollCircle=this._rollCircle??$(`#${this.id}`)?.[0]}get snap(){const t=this;return{get id(){return`${t.id}-snap`},get elem(){return t._snapCircle=t._snapCircle??$(`#${this.id}`)?.[0]},get path(){return t._rawSnapPath||(t._rawSnapPath=MotionPathPlugin.getRawPath(this.elem),MotionPathPlugin.cacheRawPathMeasurements(t._rawSnapPath)),t._rawSnapPath},get points(){return new Array(35).fill(null).map(((e,i)=>MotionPathPlugin.convertCoordinates(t.elem,RollCircle.CONTAINER,MotionPathPlugin.getPositionOnPath(this.path,gsap.utils.mapRange(0,360,0,36,i)))))}}}get slots(){return this._slots=this._slots??[]}get dice(){return this.slots.filter((t=>t instanceof XItem))}get reaitemdDice(){return this._reaitemdDice=this._reaitemdDice??[]}get rotation(){return gsap.getProperty(this.elem,"rotation")}set rotation(t){/^[+-]=/.test(`${t}`)&&(t=this.rotation+parseFloat(`${t}`.replace(/=/g,""))),gsap.set(this.elem,{rotation:t})}_create(t,e,i,s=[]){[this._rollCircle]=$(`\n    <div id="${this.id}" class="${s.join(" ")}" style="height: ${2*i}px; width: ${2*i}px;">\n      <svg height="100%" width="100%">\n        <circle cx="${i}" cy="${i}" r="${i}" stroke="none" />\n        <circle id="${this.snap.id}" class="snap-circle" cx="${i}" cy="${i}" r="${.8*i}" fill="none" stroke="none" />\n      </svg>\n    </div>\n    `).appendTo(RollCircle.CONTAINER),console.log(this),MotionPathPlugin.convertToPath(`#${this.snap.id}`),[this._snapCircle]=$(`#${this.snap.id}`),this._rawSnapPath=MotionPathPlugin.getRawPath(this.snap.elem),MotionPathPlugin.cacheRawPathMeasurements(this.snap.path),this._setCircle({xPercent:-50,yPercent:-50,x:t,y:e}),this._setSnapCircle({xPercent:-50,yPercent:-50}),this._toggleSlowRotate(!0)}_setCircle(t){gsap.set(this.elem,t)}_setSnapCircle(t){gsap.set(this.snap.elem,t)}_killTweens(t){t?[t].flat().forEach((t=>{gsap.killTweensOf(this.elem,t),"rotation"===t&&delete this._isSlowRotating})):(gsap.killTweensOf(this.elem),delete this._isSlowRotating)}_toggleSlowRotate(t){t&&this._isSlowRotating||!t&&!this._isSlowRotating||(t?this._isSlowRotating=gsap.to(this.elem,{rotation:"+=360",duration:100,repeat:-1,ease:"none",callbackScope:this,onUpdate(){this.dice.forEach((t=>t.straighten()))}}):(this._isSlowRotating.kill(),delete this._isSlowRotating))}_getAbsAngleTo({x:t,y:e}){return U.getAngle(this,{x:t,y:e})}_getRelAngleTo({x:t,y:e}){return U.cycle(this._getAbsAngleTo({x:t,y:e})-this.rotation+180,-180,180)}_getDistanceTo({x:t,y:e}){return U.getDistance(this,{x:t,y:e})}_getPosOnPath(t){return{pathPos:t,...MotionPathPlugin.getPositionOnPath(this.snap.path,t,!0)}}_getSlotPathPositions(){let t=0;return this.slots.map((e=>(t+=e.pathWeight,t-.5*e.pathWeight))).map((e=>gsap.utils.mapRange(0,1,0,t,e)))}_getNearestSlot({x:t,y:e}){if([t,e].includes(void 0))return!1;const i=this._getRelAngleTo({x:t,y:e}),s=gsap.utils.normalize(-180,180,i);let n=this.slots.findIndex(((t,e,i)=>e/i.length>=s));return-1===n&&(n=this.slots.length-1),n>0&&n/this.slots.length-s>s-(n-1)/this.slots.length&&n--,n}_getItemSlot(t,e,i=!0){let s=-1;return(e=e??(!i&&this.slots))?s=e.findIndex((e=>t instanceof XItem?t.name===e?.name:t===e)):i&&(s=this._getNearestSlot(t)),s>=0&&s}_getItemPos(t,e){const i=this._getItemSlot(t,e);if(!1!==i){const{x:t,y:s,angle:n,pathPos:r}=this._getPosOnPath(i/e.length);return{x:t,y:s,angle:n,pathPos:r,slot:i}}return!1}_getSlotsWithout(t,e){return e=e??[...this.slots],Number.isInteger(parseInt(t))?e.filter(((e,i)=>i!==parseInt(t))):t instanceof XItem?e.filter((e=>!(e instanceof XItem)||e.name!==t.name)):this.slots.filter((e=>e!==t))}_getSlotsPlus(t,e,i){return i=i??[...this.slots],e=e??i.length,[...i.slice(0,e),...[t].flat(),...i.slice(e)]}_compareSlots(t,e){function i(t,e){return t instanceof XItem&&e instanceof XItem?t.name===e.name:t===e}function s(t,e){let s=e.findIndex((e=>i(t,e)));return s===e.length-1?s=0:s++,e[s]}if(t=[...t],e=[...e],t.length!==e.length)return{isEqual:!1,isSameOrder:!1};if(t.every(((t,s)=>i(t,e[s]))))return{isEqual:!0,isSameOrder:!0};const n={isEqual:!1,isSameOrder:!0};for(const r of t)if(!i(s(r,t),s(r,e))){n.isSameOrder=!1;break}return n.isSameOrder&&(i(t[0],e[1])?n.cycleSlot=0:i(t[1],e[0])&&(n.cycleSlot=t.length-1)),n}_checkSlots(t,e){return t instanceof XItem?e.filter((e=>e instanceof XItem&&e.name===t.name)).length>0:e.includes(t)}_checkSnap(t,e){if(e=[...e],t instanceof XItem){const i=`SNAP-${t.name}`,s=e.findIndex((t=>t===i));s>=0&&(e[s]=t)}return e}async pushClockwise(t,e=1){this._getItemSlot(t,this.slots,!1)}async pushCounterClockwise(t,e=1){}async pushToSlot(t,e){}async _redistributeDice(t,e=1,i=!1){const s=[...this.slots];t=Array.isArray(t)?t:this._checkSnap(t,this.slots);const n=this._compareSlots(t,s);if(n.isEqual)return Promise.resolve();n.isSameOrder&&"cycleSlot"in n&&(t=[s[s.length-1],...s.slice(1,-1),s[0]]),this._slots=[...t];const r=Object.fromEntries(this.dice.map((t=>[t.id,this._getItemPos(t,s)]))),o=Object.fromEntries(this.dice.map((t=>[t.id,this._getItemPos(t,this.slots)]))),a=this;return Promise.allSettled(this.dice.map((t=>new Promise(((i,n)=>{let l=r[t.id]?.pathPos??0;const h=o[t.id].pathPos;a._checkSlots(t,s)&&Math.abs(l-h)>.6&&(l>h?l--:l++),console.log(gsap.to(t.elem,{motionPath:{path:a.snap.elem,alignOrigin:[.5,.5],start:l,end:h,fromCurrent:!0},duration:e,ease:"power4.out",onComplete:i,onUpdate(){},onInterrupt:n}))})))))}async _openSnapPoint(t){if(t instanceof XItem){const e=`SNAP-${t.name}`,i=this._getItemSlot(t);return this.slots[i]===e?Promise.resolve():this.slots.includes(e)?(await this._closeSnapPoint(t),this._openSnapPoint(t)):this._redistributeDice(this._getSlotsPlus(e,i))}return Promise.reject()}async _closeSnapPoint(t){return"ALL"===t?this._redistributeDice(this.dice):(t instanceof XItem&&(t=`SNAP-${t.name}`),this.slots.includes(t)?this._redistributeDice(this._getSlotsWithout(t)):Promise.resolve())}set(t){this._setCircle(t)}killItem(t){this._redistributeDice(this._getSlotsWithout(t)),t.kill()}killAll(){this.dice.forEach(this.killItem),delete this._slots}async addDice(t=1){const e=this,i=new Array(t).fill(null).map((()=>new XItem(e)));return this._redistributeDice(this._getSlotsPlus(i))}async pluckItem(t){t instanceof XItem&&this.slots.includes(t)&&(this._redistributeDice(this._getSlotsWithout(t)),this.watchItem(t))}async watchItem(t){console.log(`Readying ${t.name}`),this.reaitemdDice.filter((e=>t.name===e.name)).length||(this.reaitemdDice.push(t),console.log("... Reaitemd, Starting Watch"),this.watchDice())}async watchDice(){if(console.log("Watching ..."),this._isWatching)return;this._isWatching=this.reaitemdDice.length>0;const t=this;let e,i;console.log(`... ${this.reaitemdDice.length} Dice.`),window.requestAnimationFrame((async function s(n){if(t._isWatching&&t.reaitemdDice.length>0){e=e??n-1e3;const r=n-e;if(i!==n&&Math.floor(r/200)){let e=[...t.slots],i=!1;t.reaitemdDice.forEach((s=>{const n=`SNAP-${s.name}`,r=t._getItemSlot(s);r!==e.findIndex((t=>t===n))&&(i=!0,e=t._getSlotsPlus(n,r,t._getSlotsWithout(n,e)))})),i&&t._redistributeDice(e,.25)}i=n,window.requestAnimationFrame(s)}else console.log("No dice to watch."),t._isWatching=!1}))}unwatchItem(t){t instanceof XItem&&(this._reaitemdDice=this._reaitemdDice.filter((e=>e.name!==t.name)),this._closeSnapPoint(t))}async distDice(){}async catchItem(t){if(t.isThrowing){this._toggleSlowRotate(!1);const{tween:e,endX:i,endY:s}=t.dragger;this.ping({x:i,y:s});const n=this._getAbsAngleTo({x:i,y:s}),r=`SNAP-${t.name}`,{x:o,y:a}=(this.slots.findIndex((t=>t===r)),this._getItemPos(r,this.slots)),l=this._getAbsAngleTo({x:o,y:a}),h=U.getAngleDelta(l,n);console.log({circle:this,item:t,itemPos:{x:i,y:s,angle:parseInt(n)},snapPos:{x:o,y:a,angle:parseInt(l)},circleAngle:this.rotation,angleDelta:h});const c=e.duration()-e.time(),g=`${h>0?"+":"-"}=${Math.abs(parseInt(h))}`;console.log(g),gsap.to(this.elem,{rotation:g,duration:c,ease:"power4.out",callbackScope:this,onUpdate(){this.dice.forEach((t=>t.straighten()))},async onComplete(){t.circle=this,t.straighten(),this._toggleSlowRotate(!0),await this._redistributeDice(t),this.unwatchItem(t)}})}}}export default()=>{const t=[];return gsap.registerPlugin(Dragger,InertiaPlugin,MotionPathPlugin),[[3,45,100,100,100,{type:"lime"}],[7,-45,1370,100,100,{type:"cyan"}],[11,0,100,729,100,{type:"pink"}],[15,270,1370,729,100,{type:"yellow"}],[15,0,635,314,100,{type:"purple"}]].forEach((([e,i,...s])=>{const n=new RollCircle(...s);n.set({rotation:i}),n.addDice(e),t.push(n)})),t};